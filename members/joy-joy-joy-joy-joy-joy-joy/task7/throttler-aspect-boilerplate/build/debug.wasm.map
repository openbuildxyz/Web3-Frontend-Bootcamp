{"version":3,"sources":["~lib/rt/common.ts","~lib/as-proto/assembly/WireType.ts","~lib/rt/stub.ts","~lib/util/error.ts","~lib/as-proto/assembly/internal/FixedWriter.ts","~lib/as-proto/assembly/internal/FixedSizer.ts","~lib/shared/typeinfo.ts","~lib/shared/runtime.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/arraybuffer.ts","~lib/util/sort.ts","~lib/typedarray.ts","~lib/as-proto/assembly/Protobuf.ts","~lib/as-proto/assembly/internal/FixedReader.ts","~lib/@artela/aspect-libs/common/wraptypes/basic-types.ts","~lib/error.ts","~lib/@artela/aspect-libs/common/errors.ts","~lib/@artela/aspect-libs/hostapi/crypto-api.ts","~lib/@artela/aspect-libs/hostapi/evm-call-api.ts","~lib/@artela/aspect-libs/common/abi/ethereum/index.ts","~lib/@artela/aspect-libs/hostapi/runtime-api.ts","~lib/@artela/aspect-libs/components/aspect/aspect-context.ts","~lib/@artela/aspect-libs/hostapi/aspect-state-api.ts","~lib/@artela/aspect-libs/components/aspect/aspect-state.ts","~lib/@artela/aspect-libs/hostapi/aspect-property-api.ts","~lib/@artela/aspect-libs/components/aspect/aspect-property.ts","~lib/@artela/aspect-libs/hostapi/aspect-transient-storage-api.ts","~lib/@artela/aspect-libs/components/aspect/aspect-transient-storage.ts","~lib/@artela/aspect-libs/package.ts","~lib/@artela/aspect-libs/hostapi/statedb-api.ts","~lib/@artela/aspect-libs/hostapi/util-api.ts","~lib/@artela/aspect-libs/hostapi/trace-api.ts","~lib/@artela/aspect-libs/common/wraptypes/bigint.ts","~lib/@artela/aspect-libs/common/helper/convert.ts","~lib/@artela/aspect-libs/types/aspect-interface.ts","~lib/@artela/aspect-libs/common/helper/message.ts","~lib/@artela/aspect-libs/types/aspect-entry.ts","~lib/@artela/aspect-libs/types/entrance.ts","aspect/index.ts","~lib/string.ts","~lib/@artela/aspect-libs/proto/aspect/v2/tx-verify-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/no-from-tx-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/block-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/pre-tx-execute-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/with-from-tx-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/pre-contract-call-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/pre-exec-message-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/post-contract-call-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/post-exec-message-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/post-tx-execute-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/receipt-input.ts","~lib/@artela/aspect-libs/proto/aspect/v2/operation-input.ts","~lib/number.ts","~lib/builtins.ts","~lib/staticarray.ts","~lib/array.ts","~lib/util/bytes.ts","~lib/@artela/aspect-libs/proto/aspect/v2/uint-data.ts"],"names":[],"mappings":"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","sourceRoot":"./debug","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","export enum WireType {\n  /**\n   * int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  VARINT = 0,\n  /**\n   * fixed64, sfixed64, double\n   */\n  FIXED_64 = 1,\n  /**\n   * string, bytes, embedded messages, packed repeated fields\n   */\n  LENGTH_DELIMITED = 2,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  START_GROUP = 3,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  END_GROUP = 4,\n  /**\n   * fixed32, sfixed32, float\n   */\n  FIXED_32 = 5,\n}\n","import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \"./common\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy let offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  let pagesBefore = memory.size();\n  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let block = changetype<BLOCK>(offset);\n  let ptr = offset + BLOCK_OVERHEAD;\n  let payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  let actualSize = block.mmInfo;\n  let isLast = ptr + actualSize == offset;\n  let payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let ptr = __alloc(OBJECT_OVERHEAD + size);\n  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Writer } from \"../Writer\";\nimport { FixedSizer } from \"./FixedSizer\";\n\n/**\n * @internal\n *\n * Wire format writer using `Uint8Array`\n */\n@final\nexport class FixedWriter extends Writer {\n  /**\n   * Related sizer\n   */\n  readonly sizer: FixedSizer;\n\n  /**\n   * Current pointer.\n   */\n  private ptr: usize;\n\n  /**\n   * Fixed buffer.\n   */\n  private buf: Uint8Array;\n\n  /**\n   * Index in varlen array from sizer.\n   */\n  private varlenidx: i32;\n\n  constructor() {\n    super();\n    const sizer = this.sizer = new FixedSizer();\n    const buf = this.buf = new Uint8Array(sizer.len);\n    this.ptr = buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint<u32>(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      this.int64(value);\n    } else {\n      this.varint<u32>(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint<u32>((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint<u64>((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.fixed<u8>(value ? 1 : 0);\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  float(value: f32): void {\n    this.fixed<f32>(value);\n  }\n\n  @inline\n  double(value: f64): void {\n    this.fixed<f64>(value);\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    memory.copy(this.ptr, value.dataStart, value.byteLength);\n    this.ptr += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = this.varlen(); // use precomputed length\n    this.uint32(len);\n    String.UTF8.encodeUnsafe(changetype<usize>(value), value.length, this.ptr);\n    this.ptr += len;\n  }\n\n  @inline\n  fork(): void {\n    this.uint32(this.varlen()); // use precomputed length\n  }\n\n  @inline\n  ldelim(): void {\n    // nothing to do - all dirty work done by sizer\n  }\n\n  finish(): Uint8Array {\n    return this.buf;\n  }\n\n  reset(): void {\n    this.buf = new Uint8Array(this.sizer.len);\n    this.ptr = this.buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  private varint<T extends number>(val: T): void {\n    while (val > 0x7f) {\n      store<u8>(this.ptr++, (val & 0x7f) | 0x80);\n      val = <T>(val >>> 7);\n    }\n    store<u8>(this.ptr++, val);\n  }\n\n  @inline\n  private fixed<T extends number>(val: T): void {\n    store<T>(this.ptr, val);\n    this.ptr += sizeof<T>();\n  }\n\n  @inline\n  private varlen(): u32 {\n    return this.varlenidx >= this.sizer.varlen.length\n      ? 0\n      : this.sizer.varlen[this.varlenidx++];\n  }\n}\n","import { Writer } from \"../Writer\";\n\n/**\n * @internal\n */\n@final\nexport class FixedSizer extends Writer {\n  /**\n   * Total length.\n   */\n  len: u32;\n\n  /**\n   * Position stack.\n   */\n  readonly pos: Array<u32>;\n\n  /**\n   * Variable length list.\n   */\n  readonly varlen: Array<i32>;\n\n  /**\n   * Variable length index stack.\n   */\n  readonly varlenidx: Array<i32>;\n\n  constructor() {\n    super();\n    this.len = 0;\n    this.pos = [];\n    this.varlen = [];\n    this.varlenidx = [];\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint32(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      // 10 bytes to encode negative number\n      this.len += 10;\n    } else {\n      this.varint32(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint32((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint64((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.len += 1;\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.len += 4;\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.len += 4;\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.len += 8;\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.len += 8;\n  }\n\n  @inline\n  float(value: f32): void {\n    this.len += 4;\n  }\n\n  @inline\n  double(value: f64): void {\n    this.len += 8;\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    this.len += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = String.UTF8.byteLength(value);\n    this.varlen.push(len);\n    this.uint32(len);\n    this.len += len;\n  }\n\n  @inline\n  fork(): void {\n    this.pos.push(this.len); // save current position\n    this.varlenidx.push(this.varlen.length); // save current index in varlen array\n    this.varlen.push(0); // add 0 length to varlen array (to be updated in ldelim())\n  }\n\n  ldelim(): void {\n    assert(\n      this.pos.length && this.varlenidx.length,\n      \"Missing fork() before ldelim() call.\"\n    );\n\n    const endPos = this.len; // current position is end position\n    const startPos = this.pos.pop(); // get start position from stack\n    const idx = this.varlenidx.pop(); // get varlen index from stack\n    const len = endPos - startPos; // calculate length\n\n    this.varlen[idx] = len; // update variable length\n    this.uint32(len); // add uint32 that should be called in fork()\n  }\n\n  reset(): void {\n    this.len = 0;\n    // re-use arrays\n    this.pos.length = 0;\n    this.varlen.length = 0;\n    this.varlenidx.length = 0;\n  }\n\n  @inline\n  private varint32(value: u32): void {\n    this.len +=\n      value < 0\n        ? 10 // 10 bits with leading 1's\n        : value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : 5;\n  }\n\n  @inline\n  private varint64(value: u64): void {\n    this.len +=\n      value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : value < 0x400000000\n        ? 5\n        : value < 0x20000000000\n        ? 6\n        : value < 0x1000000000000\n        ? 7\n        : value < 0x80000000000000\n        ? 8\n        : value < 0x4000000000000000\n        ? 9\n        : 10;\n  }\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  let w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","import { FixedWriter } from \"./internal/FixedWriter\";\nimport { FixedReader } from \"./internal/FixedReader\";\nimport { Writer } from \"./Writer\";\nimport { Reader } from \"./Reader\";\n\n// re-use instances to reduce allocations and GC\nconst WRITER = new FixedWriter();\nconst READER = new FixedReader(new Uint8Array(0));\n\n@final\nexport class Protobuf {\n  static encode<TMessage>(\n    message: TMessage,\n    encoder: (message: TMessage, writer: Writer) => void\n  ): Uint8Array {\n    // 1st pass - calculate length\n    WRITER.sizer.reset();\n    encoder(message, WRITER.sizer);\n    // 2nd pass - write data using length from the 1st pass\n    WRITER.reset();\n    encoder(message, WRITER);\n    return WRITER.finish();\n  }\n\n  static decode<TMessage>(\n    buffer: Uint8Array,\n    decoder: (reader: Reader, length: i32) => TMessage,\n    length: i32 = -1\n  ): TMessage {\n    READER.reset(buffer);\n    return decoder(READER, length);\n  }\n}\n","import { Reader } from \"../Reader\";\nimport { WireType } from \"../WireType\";\n\n/**\n * @internal\n *\n * Wire format reader using `Uint8Array`\n */\n@final\nexport class FixedReader extends Reader {\n  /**\n   * Read buffer\n   */\n  private buf: Uint8Array;\n\n  constructor(buf: Uint8Array) {\n    super();\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  @inline\n  uint32(): u32 {\n    return this.varint32();\n  }\n\n  @inline\n  int32(): i32 {\n    return this.varint32();\n  }\n\n  @inline\n  sint32(): i32 {\n    const value: u32 = this.varint32();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  uint64(): u64 {\n    return this.varint64();\n  }\n\n  @inline\n  int64(): i64 {\n    return this.varint64();\n  }\n\n  @inline\n  sint64(): i64 {\n    const value = this.varint64();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  bool(): bool {\n    return this.varint32() !== 0;\n  }\n\n  @inline\n  fixed32(): u32 {\n    return load<u32>(this.inc(4));\n  }\n\n  @inline\n  sfixed32(): i32 {\n    return this.fixed32();\n  }\n\n  @inline\n  fixed64(): u64 {\n    return load<u64>(this.inc(8));\n  }\n\n  @inline\n  sfixed64(): u64 {\n    return this.fixed64();\n  }\n\n  @inline\n  float(): f32 {\n    return load<f32>(this.inc(4));\n  }\n\n  @inline\n  double(): f64 {\n    return load<f64>(this.inc(8));\n  }\n\n  bytes(): Uint8Array {\n    const length = this.uint32();\n    const buffer = new Uint8Array(length);\n    memory.copy(buffer.dataStart, this.inc(length), length);\n    return buffer;\n  }\n\n  string(): string {\n    const length = this.uint32();\n    return String.UTF8.decodeUnsafe(this.inc(length), length);\n  }\n\n  skip(length: u32): void {\n    if (length === 0) {\n      // skip varint\n      while (load<u8>(this.inc()) & 0x80);\n    } else {\n      this.inc(length);\n    }\n  }\n\n  skipType(wireType: WireType = WireType.VARINT): void {\n    switch (wireType) {\n      case WireType.VARINT:\n        this.skip(0);\n        break;\n      case WireType.FIXED_64:\n        this.skip(8);\n        break;\n      case WireType.LENGTH_DELIMITED:\n        this.skip(this.uint32());\n        break;\n      case WireType.START_GROUP:\n        while ((wireType = this.uint32() & 0x07) !== WireType.END_GROUP) {\n          this.skipType(wireType);\n        }\n        break;\n      case WireType.FIXED_32:\n        this.skip(4);\n        break;\n      default:\n        throw new Error(\"Invalid wire type \" + wireType.toString());\n    }\n  }\n\n  reset(buf: Uint8Array): void {\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  private varint32(): u32 {\n    let loaded: u32;\n    let value: u32;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0xf) << 28;\n    if (loaded < 0x80) return value;\n\n    // increment position until there is no continuation bit or until we read 10 bytes\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n\n    return value;\n  }\n\n  private varint64(): u64 {\n    let loaded: u64;\n    let value: u64;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 28;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 35;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 42;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 49;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 56;\n    if (loaded < 0x80) return value;\n\n    value |= (load<u8>(this.inc()) & 0x1) << 63;\n\n    return value;\n  }\n\n  @inline\n  private inc(step: u32 = 1): usize {\n    const ptr = this.ptr;\n    this.ptr += step;\n    assert(this.ptr <= this.end, \"Index out of range\");\n\n    return ptr;\n  }\n}\n","export enum typeIndex {\n  Empty = 0,\n  TypeInt8,\n  TypeInt16,\n  TypeInt32,\n  TypeInt64,\n  TypeUint8,\n  TypeUint16,\n  TypeUint32,\n  TypeUint64,\n  TypeBool,\n  TypeString, // string with utf-8 encoder\n  TypeByteArray,\n}\n\nclass header {\n  load(ptr: i32): void {\n    this.dataType = i16(i32.load16_s(ptr));\n    this.dataLen = i32.load(ptr + 2);\n  }\n\n  store(ptr: i32): void {\n    i32.store16(ptr, this.dataType);\n    i32.store(ptr + 2, this.dataLen);\n  }\n\n  len(): i32 {\n    return 6; // i16 + i32\n  }\n\n  dataType: i16;\n  dataLen: i32;\n\n  constructor(type: typeIndex = typeIndex.TypeInt8, len: i32 = 0) {\n    this.dataType = type as i16;\n    this.dataLen = len;\n  }\n}\n\nexport class AString {\n  public set(s: string): void {\n    this.body = s;\n    this.head.dataLen = String.UTF8.byteLength(s);\n  }\n\n  public get(): string {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    const bodyPtr = ptr + this.head.len();\n    // read as a utf8 string\n    this.body = String.UTF8.decodeUnsafe(bodyPtr, this.head.dataLen);\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    let bodyPtr = ptr + this.head.len();\n    // utf-16 <--> utf8\n    const encoded = Uint8Array.wrap(String.UTF8.encode(this.body));\n    for (let i = 0; i < encoded.length; i++) {\n      memory.fill(bodyPtr, encoded[i], 1);\n      bodyPtr++;\n    }\n\n    return ptr;\n  }\n\n  head: header;\n  body: string; // utf-16 encoder\n\n  constructor(body: string = '') {\n    this.body = body;\n    this.head = new header(typeIndex.TypeString, String.UTF8.byteLength(body));\n  }\n}\n\nexport class AUint8Array {\n  public set(data: Uint8Array): void {\n    this.body = data;\n    this.head.dataLen = data.length;\n  }\n\n  public get(): Uint8Array {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    let bodyPtr = ptr + this.head.len();\n    this.body = new Uint8Array(this.head.dataLen);\n    for (let i = 0; i < this.head.dataLen; i++) {\n      this.body[i] = u8(i32.load8_u(bodyPtr));\n      bodyPtr++;\n    }\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    let bodyPtr = ptr + this.head.len();\n    for (let i = 0; i < this.head.dataLen; i++) {\n      memory.fill(bodyPtr, this.body[i], 1);\n      bodyPtr++;\n    }\n    return ptr;\n  }\n\n  head: header;\n  body: Uint8Array;\n\n  constructor(body: Uint8Array = new Uint8Array(0)) {\n    this.body = body;\n    this.head = new header(typeIndex.TypeByteArray, body.length);\n  }\n}\n\nexport class ABool {\n  public set(data: bool): void {\n    this.body = data;\n    this.head.dataLen = 1;\n  }\n\n  public get(): bool {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    const bodyPtr = ptr + this.head.len();\n    this.body = u8(i32.load8_u(bodyPtr)) != 0;\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    const bodyPtr = ptr + this.head.len();\n    memory.fill(bodyPtr, this.body ? 1 : 0, 1);\n    return ptr;\n  }\n\n  head: header;\n  body: bool;\n\n  constructor(body: bool = false) {\n    this.body = body;\n    this.head = new header(typeIndex.TypeBool, 1);\n  }\n}\n\nexport class AI32 {\n  public set(data: i32): void {\n    this.body = data;\n    this.head.dataLen = 4;\n  }\n\n  public get(): i32 {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    const bodyPtr = ptr + this.head.len();\n    this.body = i32.load(bodyPtr);\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    const bodyPtr = ptr + this.head.len();\n    i32.store(bodyPtr, this.body);\n    return ptr;\n  }\n\n  head: header;\n  body: i32;\n\n  constructor(body: i32 = 0) {\n    this.body = body;\n    this.head = new header(typeIndex.TypeInt32, 4);\n  }\n}\n\nexport class AI64 {\n  public set(data: i64): void {\n    this.body = data;\n    this.head.dataLen = 8;\n  }\n\n  public get(): i64 {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    const bodyPtr = ptr + this.head.len();\n    this.body = i64.load(bodyPtr);\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    const bodyPtr = ptr + this.head.len();\n    i64.store(bodyPtr, this.body);\n    return ptr;\n  }\n\n  head: header;\n  body: i64;\n\n  constructor(body: i64 = 0) {\n    this.body = body;\n    this.head = new header(typeIndex.TypeInt64, 8);\n  }\n}\n\nexport class AU64 {\n  public set(data: u64): void {\n    this.body = data;\n    this.head.dataLen = 8;\n  }\n\n  public get(): u64 {\n    return this.body;\n  }\n\n  public load(ptr: i32): void {\n    this.head = new header(0, 0);\n    this.head.load(ptr);\n    const bodyPtr = ptr + this.head.len();\n    this.body = i64.load(bodyPtr);\n  }\n\n  public store(): i32 {\n    const ptr = heap.alloc(this.head.dataLen + this.head.len()) as i32;\n    this.head.store(ptr);\n    const bodyPtr = ptr + this.head.len();\n    i64.store(bodyPtr, this.body);\n    return ptr;\n  }\n\n  head: header;\n  body: u64;\n\n  constructor(body: u64 = 0) {\n    this.body = body;\n    this.head = new header(typeIndex.TypeUint64, 8);\n  }\n}\n","export class Error {\n\n  name: string  = \"Error\";\n  stack: string = \"\"; // TODO\n\n  constructor(\n    public message: string = \"\"\n  ) {}\n\n  toString(): string {\n    let message = this.message;\n    return message.length\n      ? this.name + \": \" + message\n      : this.name;\n  }\n}\n\nexport class RangeError extends Error {\n  constructor(message: string = \"\") {\n    super(message);\n    this.name = \"RangeError\";\n  }\n}\n\nexport class TypeError extends Error {\n  constructor(message: string = \"\") {\n    super(message);\n    this.name = \"TypeError\";\n  }\n}\n\nexport class SyntaxError extends Error {\n  constructor(message: string = \"\") {\n    super(message);\n    this.name = \"SyntaxError\";\n  }\n}\n\nexport class URIError extends Error {\n  constructor(message: string = \"\") {\n    super(message);\n    this.name = \"URIError\";\n  }\n}\n","export const ErrLoadRuntimeCtxValue = new Error('load runtime context value failed');\nexport const ErrLoadAspectProperty = new Error('failed to load aspect property');\nexport const ErrLoadAspectContext = new Error('failed to load aspect context');\nexport const ErrLoadAspectState = new Error('failed to read aspect state value');\nexport const ErrUpdateAspectState = new Error('failed to update aspect state value');\n\nexport const ErrParseValueFail = new Error('unable to parse aspect value');\nexport const NotAuthorizedFail = new Error('unknowable context, not authorized to initialize');\n\nexport function NewMessageError(msg: string): Error {\n  return new Error(msg);\n}\n","import { AUint8Array, BigInt, hexToUint8Array, uint8ArrayToHex } from '../common';\n\ndeclare namespace __CryptoApi__ {\n  function sha256(dataPtr: i32): i32;\n\n  function ripemd160(dataPtr: i32): i32;\n\n  function keccak(dataPtr: i32): i32;\n\n  function ecRecover(dataPtr: i32): i32;\n}\n\nexport class CryptoApi {\n  private static _ins: CryptoApi | null = null;\n\n  private constructor() {}\n\n  public static instance(): CryptoApi {\n    if (!CryptoApi._ins) {\n      CryptoApi._ins = new CryptoApi();\n    }\n    return CryptoApi._ins!;\n  }\n\n  public keccak(data: Uint8Array): Uint8Array {\n    const dataPtr = new AUint8Array(data).store();\n    const resPtr = __CryptoApi__.keccak(dataPtr);\n    const resRaw = new AUint8Array();\n    resRaw.load(resPtr);\n    return resRaw.body;\n  }\n\n  public sha256(data: Uint8Array): Uint8Array {\n    const dataPtr = new AUint8Array(data).store();\n    const resPtr = __CryptoApi__.sha256(dataPtr);\n    const resRaw = new AUint8Array();\n    resRaw.load(resPtr);\n    return resRaw.body;\n  }\n\n  public ripemd160(data: Uint8Array): Uint8Array {\n    const dataPtr = new AUint8Array(data).store();\n    const resPtr = __CryptoApi__.ripemd160(dataPtr);\n    const resRaw = new AUint8Array();\n    resRaw.load(resPtr);\n    return resRaw.body;\n  }\n\n  /**\n   * recover the address associated with the public key from elliptic curve signature or return zero on error.\n   * The function parameters correspond to ECDSA values of the signature:\n   * @param hash\n   * @param v final 32 bytes of signature\n   * @param r  first 32 bytes of signature\n   * @param s  second 32 bytes of signature\n   *\n   * @returns string returns an address, and not an address payable\n   */\n  public ecRecover(hash: string, v: BigInt, r: BigInt, s: BigInt): string {\n    if (\n      v.countBits() == 0 ||\n      r.countBits() == 0 ||\n      s.countBits() == 0 ||\n      v.countBits() > 256 ||\n      r.countBits() > 256 ||\n      s.countBits() > 256\n    ) {\n      return '';\n    }\n    const vStr = v.countBits() == 256 ? v.toString(16) : v.toString(16).padStart(64, '0');\n    const rStr = r.countBits() == 256 ? r.toString(16) : r.toString(16).padStart(64, '0');\n    const sStr = s.countBits() == 256 ? s.toString(16) : s.toString(16).padStart(64, '0');\n\n    //[msgHash 32B][v 32B][r 32B][s 32B]\n    const syscallInput = hash + vStr + rStr + sStr;\n    const ret = this._ecRecover(hexToUint8Array(syscallInput));\n    return uint8ArrayToHex(ret);\n  }\n\n  private _ecRecover(data: Uint8Array): Uint8Array {\n    const dataPtr = new AUint8Array(data).store();\n    const resPtr = __CryptoApi__.ecRecover(dataPtr);\n    const resRaw = new AUint8Array();\n    resRaw.load(resPtr);\n    return resRaw.body;\n  }\n}\n","import { Protobuf } from 'as-proto/assembly';\nimport { AUint8Array, ethereum, hexToUint8Array } from '../common';\nimport {\n  JitInherentRequest,\n  JitInherentResponse,\n  StaticCallRequest,\n  StaticCallResult,\n} from '../proto';\n\ndeclare namespace __EvmCallApi__ {\n  function staticCall(request: i32): i32;\n\n  function jitCall(request: i32): i32;\n}\n\nexport class JitCallBuilder {\n  private _sender: Uint8Array;\n  private _nonce: u64;\n  private _nonceKey: string;\n  private _initCode: Uint8Array;\n  private _callData: Uint8Array;\n  private _callGasLimit: u64;\n  private _verificationGasLimit: u64;\n  private _paymasterAndData: Uint8Array;\n\n  constructor() {\n    this._sender = new Uint8Array(0);\n    this._nonce = 0;\n    this._nonceKey = '';\n    this._initCode = new Uint8Array(0);\n    this._callData = new Uint8Array(0);\n    this._callGasLimit = 0;\n    this._verificationGasLimit = 0;\n    this._paymasterAndData = new Uint8Array(0);\n  }\n\n  static simple(sender: Uint8Array, to: Uint8Array, methodCallData: Uint8Array): JitCallBuilder {\n    const walletCallData = ethereum.abiEncode('execute', [\n      ethereum.Address.fromUint8Array(to),\n      ethereum.Number.fromU64(0),\n      ethereum.Bytes.fromUint8Array(methodCallData),\n    ]);\n    return new JitCallBuilder().sender(sender).callData(hexToUint8Array(walletCallData));\n  }\n\n  sender(sender: Uint8Array): JitCallBuilder {\n    if (sender.length != 20) {\n      throw new Error('invalid sender length');\n    }\n    this._sender = sender;\n    return this;\n  }\n\n  nonce(nonce: u64): JitCallBuilder {\n    this._nonce = nonce;\n    return this;\n  }\n\n  nonceKey(nonceKey: string): JitCallBuilder {\n    nonceKey = nonceKey.startsWith('0x') ? nonceKey.substr(2) : nonceKey;\n    if (nonceKey.length != 48) {\n      throw new Error('nonce key must be 24 bytes');\n    }\n\n    this._nonceKey = nonceKey;\n    return this;\n  }\n\n  initCode(initCode: Uint8Array): JitCallBuilder {\n    this._initCode = initCode;\n    return this;\n  }\n\n  callData(callData: Uint8Array): JitCallBuilder {\n    this._callData = callData;\n    return this;\n  }\n\n  callGasLimit(callGasLimit: u64): JitCallBuilder {\n    this._callGasLimit = callGasLimit;\n    return this;\n  }\n\n  verificationGasLimit(verificationGasLimit: u64): JitCallBuilder {\n    this._verificationGasLimit = verificationGasLimit;\n    return this;\n  }\n\n  paymasterAndData(paymasterAndData: Uint8Array): JitCallBuilder {\n    this._paymasterAndData = paymasterAndData;\n    return this;\n  }\n\n  build(): JitInherentRequest {\n    return new JitInherentRequest(\n      ethereum.Address.fromUint8Array(this._sender),\n      this._nonce,\n      hexToUint8Array(this._nonceKey),\n      this._initCode,\n      this._callData,\n      this._callGasLimit,\n      this._verificationGasLimit,\n      this._paymasterAndData,\n    );\n  }\n}\n\nexport class EvmCallApi {\n  private static _instance: EvmCallApi | null = null;\n\n  private constructor() {}\n\n  public static instance(): EvmCallApi {\n    if (!this._instance) {\n      this._instance = new EvmCallApi();\n    }\n    return this._instance!;\n  }\n\n  public staticCall(request: StaticCallRequest): StaticCallResult {\n    const encoded = Protobuf.encode(request, StaticCallRequest.encode);\n    const input = new AUint8Array();\n    input.set(encoded);\n    const inputPtr = input.store();\n    const ret = __EvmCallApi__.staticCall(inputPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return Protobuf.decode<StaticCallResult>(bytes.get(), StaticCallResult.decode);\n  }\n\n  public jitCall(request: JitInherentRequest): JitInherentResponse {\n    const encoded = Protobuf.encode(request, JitInherentRequest.encode);\n    const input = new AUint8Array();\n    input.set(encoded);\n    const inputPtr = input.store();\n    const ret = __EvmCallApi__.jitCall(inputPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return Protobuf.decode<JitInherentResponse>(bytes.get(), JitInherentResponse.decode);\n  }\n}\n","import { CryptoApi } from '../../../hostapi';\nimport {\n  encodeStringUTF8,\n  hexToUint8Array,\n  stringToUint8Array,\n  uint8ArrayToHex,\n} from '../../helper/convert';\n\nconst crypto = CryptoApi.instance();\n\nexport namespace ethereum {\n  export function parseMethodSig(calldata: Uint8Array): string {\n    if (calldata.length < 4) {\n      return '';\n    }\n\n    return uint8ArrayToHex(calldata.slice(0, 4));\n  }\n\n  export function computeMethodSig(method: string): string {\n    return uint8ArrayToHex(crypto.keccak(stringToUint8Array(method)).slice(0, 4));\n  }\n\n  export function abiEncode(method: string, types: Type[]): string {\n    let enc = '0x';\n    if (method.length > 0) {\n      const methodWithArgTypes =\n        method + '(' + types.map((t: Type) => t.typeName()).join(',') + ')';\n      enc += computeMethodSig(methodWithArgTypes);\n    }\n\n    let inputOffset: u64 = 0;\n    for (let i = 0; i < types.length; ++i) {\n      inputOffset += types[i].typeSize();\n    }\n\n    let variableInput = '';\n    for (let i = 0; i < types.length; ++i) {\n      const t = types[i];\n      const val = t.encodeHex();\n      if (t.isDynamicType()) {\n        enc += Number.fromU64(inputOffset).encodeHex();\n        inputOffset += val.length >> 1;\n        variableInput += val;\n      } else {\n        enc += val;\n      }\n    }\n\n    return enc + variableInput;\n  }\n\n  enum TypeId {\n    Number,\n    BytesN,\n    Address,\n    Boolean,\n    Array,\n    Tuple,\n    Bytes,\n    String,\n  }\n\n  export interface Type {\n    /**\n     * encode type to hex\n     */\n    encodeHex(): string;\n\n    /**\n     * encode type to Uint8Array\n     */\n    encodeUint8Array(): Uint8Array;\n\n    /**\n     * return name of the type, used to generate function signature\n     */\n    typeName(): string;\n\n    /**\n     * type kind\n     */\n    typeKind(): TypeId;\n\n    /**\n     * true if type is dynamic, otherwise false\n     */\n    isDynamicType(): boolean;\n\n    /**\n     * encode size of the type\n     */\n    typeSize(): u64;\n  }\n\n  export class ByteArray extends Uint8Array implements Type {\n    protected static validateAndTrimHex(hex: string, paddingLeft: boolean = false): string {\n      assert(hex.length % 2 == 0, 'input ' + hex + ' has odd length');\n\n      // Skip possible `0x` prefix.\n      if (hex.length >= 2 && hex.charAt(0) == '0' && hex.charAt(1) == 'x') {\n        hex = hex.substr(2);\n      }\n\n      if (paddingLeft) {\n        assert(hex.length <= 64, 'input data length too long');\n      }\n\n      return hex;\n    }\n\n    protected static calcPaddedLen(length: u64): i32 {\n      return ((((length >> 1) + 31) >> 5) << 5) as i32;\n    }\n\n    protected static fromHex(\n      hex: string,\n      output: ByteArray,\n      paddingLeft: boolean = false,\n    ): ByteArray {\n      if (paddingLeft) {\n        const paddingOffset = (64 - hex.length) >> 1;\n        for (let i = 0; i < hex.length; i += 2) {\n          output[paddingOffset + (i >> 1)] = U8.parseInt(hex.substr(i, 2), 16);\n        }\n      } else {\n        for (let i = 0; i < hex.length; i += 2) {\n          output[i >> 1] = U8.parseInt(hex.substr(i, 2), 16);\n        }\n      }\n\n      return output;\n    }\n\n    protected static fromBuffer(\n      buffer: ArrayBuffer,\n      output: ByteArray,\n      paddingLeft: boolean = false,\n    ): ByteArray {\n      const uint8Array = Uint8Array.wrap(buffer);\n      if (paddingLeft) {\n        const paddingOffset = 32 - buffer.byteLength;\n        for (let i = 0; i < buffer.byteLength; ++i) {\n          output[paddingOffset + i] = uint8Array[i];\n        }\n      } else {\n        for (let i = 0; i < buffer.byteLength; ++i) {\n          output[i] = uint8Array[i];\n        }\n      }\n\n      return output;\n    }\n\n    encodeHex(): string {\n      let res = '';\n      for (let i = 0; i < this.length; ++i) {\n        let hex = this[i].toString(16);\n        hex = hex.length % 2 == 0 ? hex : '0' + hex;\n        res += hex;\n      }\n\n      return res;\n    }\n\n    encodeUint8Array(): Uint8Array {\n      return hexToUint8Array(this.encodeHex());\n    }\n\n    typeName(): string {\n      throw new Error('method not implemented.');\n    }\n\n    isDynamicType(): boolean {\n      return false;\n    }\n\n    typeSize(): u64 {\n      return 32;\n    }\n\n    typeKind(): TypeId {\n      throw new Error('method not implemented.');\n    }\n\n    @operator('==')\n    static equals(a: ByteArray, b: ByteArray): bool {\n      if (a.length != b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < a.length; ++i) {\n        if (a[i] != b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  /** A dynamically-sized byte array. */\n  export class Bytes extends ByteArray {\n    protected readonly contentLen: u64;\n\n    protected constructor(length: u64) {\n      super(ByteArray.calcPaddedLen(length));\n      this.contentLen = length >> 1;\n    }\n\n    /**\n     * Convert the string `hex` which must consist of an even number of\n     * hexadecimal digits to a `ByteArray`. The string `hex` can optionally\n     * start with '0x'\n     */\n    static fromHexString(str: string): Bytes {\n      str = this.validateAndTrimHex(str);\n      return changetype<Bytes>(this.fromHex(str, new Bytes(str.length)));\n    }\n\n    static fromUint8Array(arr: Uint8Array): Bytes {\n      return changetype<Bytes>(this.fromBuffer(arr.buffer, new Bytes(arr.length << 1)));\n    }\n\n    encodeHex(): string {\n      return Number.fromU64(this.contentLen).encodeHex() + super.encodeHex();\n    }\n\n    encodeUint8Array(): Uint8Array {\n      return hexToUint8Array(this.encodeHex());\n    }\n\n    typeName(): string {\n      return 'bytes';\n    }\n\n    isDynamicType(): boolean {\n      return true;\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Bytes;\n    }\n\n    @operator('==')\n    static equals(a: Bytes, b: Bytes): bool {\n      return ByteArray.equals(a, b);\n    }\n  }\n\n  export class String extends Bytes {\n    static fromString(str: string): ethereum.String {\n      return changetype<ethereum.String>(\n        this.fromBuffer(encodeStringUTF8(str), new ethereum.String(str.length)),\n      );\n    }\n\n    static fromUTF16String(str: string): ethereum.String {\n      return this.fromString(str);\n    }\n\n    static fromUint8Array(arr: Uint8Array): ethereum.String {\n      return changetype<ethereum.String>(\n        this.fromBuffer(arr.buffer, new ethereum.String(arr.length << 1)),\n      );\n    }\n\n    public typeName(): string {\n      return 'string';\n    }\n\n    typeKind(): TypeId {\n      return TypeId.String;\n    }\n\n    @operator('==')\n    static equals(a: String, b: String): bool {\n      return ByteArray.equals(a, b);\n    }\n  }\n\n  /** A fixed-sized byte array. */\n  export class BytesN extends ByteArray {\n    private readonly _byteSize: u8 = 32;\n\n    private constructor(size: u8) {\n      super(32);\n      this._byteSize = size;\n    }\n\n    get byteSize(): u8 {\n      return this._byteSize;\n    }\n\n    /**\n     * Convert the string `hex` which must consist of an even number of\n     * hexadecimal digits to a `ByteArray`. The string `hex` can optionally\n     * start with '0x'\n     */\n    static fromHexString(str: string, size: u8 = 32): BytesN {\n      assert(size <= 32 && size > 0, 'invalid byte size');\n\n      str = this.validateAndTrimHex(str);\n      return changetype<BytesN>(this.fromHex(str, new BytesN(size)));\n    }\n\n    static fromUint8Array(arr: Uint8Array, size: u8 = 32): BytesN {\n      assert(size <= 32 && size > 0, 'invalid byte size');\n      return changetype<BytesN>(this.fromBuffer(arr.buffer, new BytesN(size)));\n    }\n\n    public typeName(): string {\n      return 'bytes' + this._byteSize.toString(10);\n    }\n\n    typeKind(): TypeId {\n      return TypeId.BytesN;\n    }\n\n    @operator('==')\n    static equals(a: BytesN, b: BytesN): bool {\n      if (a._byteSize != b._byteSize) {\n        return false;\n      }\n\n      return ByteArray.equals(a, b);\n    }\n  }\n\n  export class Number extends ByteArray {\n    protected _byteSize: u8 = 32;\n    private readonly _signed: boolean;\n\n    protected constructor(signed: boolean = false, bitSize: u16 = 256) {\n      assert(bitSize >= 8 && bitSize <= 256, 'number size must between 8 ~ 256');\n      assert(bitSize % 8 == 0, 'number size must be multiple of 8');\n\n      super(32);\n      this._signed = signed;\n      this._byteSize = (bitSize >> 3) as u8;\n    }\n\n    get byteSize(): u8 {\n      return this._byteSize;\n    }\n\n    get bitSize(): u16 {\n      return this._byteSize * 8;\n    }\n\n    get signed(): boolean {\n      return this._signed;\n    }\n\n    static fromHexString(str: string, signed: boolean = false, bitSize: u16 = 256): Number {\n      return this.fromHexStringWithBuffer(str, new ethereum.Number(signed, bitSize));\n    }\n\n    static fromUint8Array(arr: Uint8Array, signed: boolean = false, bitSize: u16 = 256): Number {\n      return this.fromUint8ArrayWithBuffer(arr, new ethereum.Number(signed, bitSize));\n    }\n\n    protected static fromHexStringWithBuffer(str: string, buffer: Number): Number {\n      str = this.validateAndTrimHex(str);\n      return changetype<Number>(this.fromHex(str, buffer, true));\n    }\n\n    protected static fromUint8ArrayWithBuffer(arr: Uint8Array, buffer: Number): Number {\n      return changetype<Number>(this.fromBuffer(arr.buffer, buffer, true));\n    }\n\n    static fromI8(x: i8, bitSize: u16 = 256): Number {\n      return Number.fromI64(x, bitSize);\n    }\n\n    static fromU8(x: u8, bitSize: u16 = 256): Number {\n      return Number.fromU64(x, bitSize);\n    }\n\n    static fromI16(x: i16, bitSize: u16 = 256): Number {\n      return Number.fromI16(x, bitSize);\n    }\n\n    static fromU16(x: u16, bitSize: u16 = 256): Number {\n      return Number.fromU64(x, bitSize);\n    }\n\n    static fromI32(x: i32, bitSize: u16 = 256): Number {\n      return Number.fromI32(x, bitSize);\n    }\n\n    static fromU32(x: u32, bitSize: u16 = 256): Number {\n      return Number.fromU64(x, bitSize);\n    }\n\n    static fromI64(x: i64, bitSize: u16 = 256): Number {\n      return Number.fromU64(x, bitSize, true);\n    }\n\n    static fromU64(x: u64, bitSize: u16 = 256, signed: boolean = false): Number {\n      assert(bitSize >= 8 && bitSize <= 256, 'number bit size must between 8 ~ 256');\n      assert(bitSize % 8 == 0, 'number bit size must be multiple of 8');\n\n      const self = new ethereum.Number(signed, bitSize);\n\n      self[31] = x as u8;\n      self[30] = (x >> 8) as u8;\n      self[29] = (x >> 16) as u8;\n      self[28] = (x >> 24) as u8;\n      self[27] = (x >> 32) as u8;\n      self[26] = (x >> 40) as u8;\n      self[25] = (x >> 48) as u8;\n      self[24] = (x >> 56) as u8;\n\n      return self;\n    }\n\n    typeName(): string {\n      return (this._signed ? 'int' : 'uint') + ((this._byteSize as u16) * 8).toString();\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Number;\n    }\n\n    @operator('==')\n    static equals(a: Number, b: Number): bool {\n      if (a._byteSize != b._byteSize) {\n        return false;\n      }\n\n      return ByteArray.equals(a, b);\n    }\n\n    @operator('>')\n    static greater(a: Number, b: Number): bool {\n      for (let i = 0; i < 32; ++i) {\n        if (a[i] > b[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    @operator('>=')\n    static greaterEq(a: Number, b: Number): bool {\n      for (let i = 0; i < 32; ++i) {\n        if (a[i] < b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    @operator('<')\n    static less(a: Number, b: Number): bool {\n      return !this.greaterEq(a, b);\n    }\n\n    @operator('<=')\n    static lessEq(a: Number, b: Number): bool {\n      return !this.greater(a, b);\n    }\n  }\n\n  export class Uint extends Number {\n    static fromHexString(str: string): Uint {\n      return changetype<Uint>(super.fromHexStringWithBuffer(str, new Uint()));\n    }\n\n    static fromUint8Array(arr: Uint8Array): Uint {\n      return changetype<Uint>(this.fromUint8ArrayWithBuffer(arr, new Uint()));\n    }\n\n    public typeName(): string {\n      return 'uint';\n    }\n\n    @operator('==')\n    static equals(a: Uint, b: Uint): bool {\n      return Number.equals(a, b);\n    }\n\n    @operator('>')\n    static greater(a: Uint, b: Uint): bool {\n      return Number.greater(a, b);\n    }\n\n    @operator('>=')\n    static greaterEq(a: Uint, b: Uint): bool {\n      return Number.greaterEq(a, b);\n    }\n\n    @operator('<')\n    static less(a: Uint, b: Uint): bool {\n      return Number.less(a, b);\n    }\n\n    @operator('<=')\n    static lessEq(a: Uint, b: Uint): bool {\n      return Number.lessEq(a, b);\n    }\n  }\n\n  export class Int extends Number {\n    static fromHexString(str: string): Int {\n      return changetype<Int>(super.fromHexStringWithBuffer(str, new Int(true)));\n    }\n\n    static fromUint8Array(arr: Uint8Array): Int {\n      return changetype<Int>(this.fromUint8ArrayWithBuffer(arr, new Int()));\n    }\n\n    public typeName(): string {\n      return 'int';\n    }\n\n    @operator('==')\n    static equals(a: Int, b: Int): bool {\n      return Number.equals(a, b);\n    }\n\n    @operator('>')\n    static greater(a: Int, b: Int): bool {\n      return Number.greater(a, b);\n    }\n\n    @operator('>=')\n    static greaterEq(a: Int, b: Int): bool {\n      return Number.greaterEq(a, b);\n    }\n\n    @operator('<')\n    static less(a: Int, b: Int): bool {\n      return Number.less(a, b);\n    }\n\n    @operator('<=')\n    static lessEq(a: Int, b: Int): bool {\n      return Number.lessEq(a, b);\n    }\n  }\n\n  /** An Ethereum address (20 bytes). */\n  export class Address extends Number {\n    private constructor() {\n      super(false, 160);\n    }\n\n    static fromHexString(str: string): Address {\n      assert(str.length == (str.startsWith('0x') ? 42 : 40), 'invalid address');\n      return changetype<Address>(this.fromHexStringWithBuffer(str, new Address()));\n    }\n\n    static fromUint8Array(arr: Uint8Array): Address {\n      return changetype<Address>(this.fromUint8ArrayWithBuffer(arr, new Address()));\n    }\n\n    typeName(): string {\n      return 'address';\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Address;\n    }\n\n    @operator('==')\n    static equals(a: Address, b: Address): bool {\n      return Number.equals(a, b);\n    }\n  }\n\n  export class Boolean extends ByteArray {\n    private constructor(val: boolean) {\n      super(32);\n      this[31] = val ? 1 : 0;\n    }\n\n    static fromBoolean(x: boolean): Boolean {\n      return new ethereum.Boolean(x);\n    }\n\n    static fromUint8Array(arr: Uint8Array): Boolean {\n      assert(arr.length == 32, 'invalid boolean uint8 array data');\n      return new ethereum.Boolean(arr[31] == 1);\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Boolean;\n    }\n\n    public typeName(): string {\n      return 'bool';\n    }\n\n    @operator('==')\n    static equals(a: Boolean, b: Boolean): bool {\n      return ByteArray.equals(a, b);\n    }\n  }\n\n  export class ArraySlice implements Type {\n    private _elements: Type[] = [];\n\n    private readonly _size: u64;\n\n    get elementTypeName(): string {\n      return this._elements[0].typeName();\n    }\n\n    get isFixedSize(): boolean {\n      return this._size > 0;\n    }\n\n    get elements(): ethereum.Type[] {\n      return this._elements;\n    }\n\n    private constructor(coders: ethereum.Type[], _size: u64) {\n      assert(coders.length > 0, 'empty array');\n      assert(_size == 0 || coders.length == _size, 'input does not match fixed array size');\n\n      const typeKind = coders[0].typeKind();\n\n      for (let i = 0; i < coders.length; ++i) {\n        if (i > 1) {\n          assert(typeKind == coders[i].typeKind(), 'coders in an array must have the same type');\n        }\n        this._elements.push(coders[i]);\n      }\n\n      this._size = _size;\n    }\n\n    static fromCoders(coders: ethereum.Type[], _size: u64 = 0): ethereum.ArraySlice {\n      return new ethereum.ArraySlice(coders, _size);\n    }\n\n    encodeHex(): string {\n      let res = '';\n      const valLen = this._elements.length;\n      if (!this.isFixedSize) {\n        res += ethereum.Number.fromU64(valLen).encodeHex();\n      }\n\n      let offset: u64 = 0;\n      const offsetRequired = this._elements[0].isDynamicType();\n      if (offsetRequired) {\n        offset = this._elements[0].typeSize() * valLen;\n      }\n\n      let tail = '';\n      for (let i = 0; i < valLen; ++i) {\n        const e = this._elements[i];\n        const val = e.encodeHex();\n        if (offsetRequired) {\n          res += ethereum.Number.fromU64(offset).encodeHex();\n          offset += val.length >> 1;\n          tail += val;\n        } else {\n          res += val;\n        }\n      }\n\n      return res + tail;\n    }\n\n    encodeUint8Array(): Uint8Array {\n      return hexToUint8Array(this.encodeHex());\n    }\n\n    typeName(): string {\n      assert(this._elements.length > 0, 'empty array');\n      return this._elements[0].typeName() + '[]';\n    }\n\n    isDynamicType(): boolean {\n      return !this.isFixedSize || this._elements[0].isDynamicType();\n    }\n\n    typeSize(): u64 {\n      const element = this._elements[0];\n      if (this.isFixedSize && !element.isDynamicType()) {\n        if (element.typeKind() == TypeId.Tuple || element.typeKind() == TypeId.Array) {\n          return this._size * element.typeSize();\n        }\n\n        return this._size * 32;\n      }\n\n      return 32;\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Array;\n    }\n  }\n\n  export class Tuple implements Type {\n    private _members: Type[] = [];\n\n    private constructor(coders: Type[]) {\n      assert(coders.length > 0, 'empty tuple');\n\n      for (let i = 0; i < coders.length; ++i) {\n        this._members.push(coders[i]);\n      }\n    }\n\n    static fromCoders(coders: Type[]): Tuple {\n      return new Tuple(coders);\n    }\n\n    get members(): Type[] {\n      return this._members;\n    }\n\n    typeName(): string {\n      let res = '(';\n      for (let i = 0; i < this._members.length; ++i) {\n        const typeName = this._members[i].typeName();\n        res += i > 0 ? ',' + typeName : typeName;\n      }\n      res += ')';\n\n      return res;\n    }\n\n    isDynamicType(): boolean {\n      for (let i = 0; i < this._members.length; ++i) {\n        if (this._members[i].isDynamicType()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    typeKind(): TypeId {\n      return TypeId.Tuple;\n    }\n\n    typeSize(): u64 {\n      if (this.isDynamicType()) {\n        return 32;\n      }\n\n      let total: u64 = 0;\n      for (let i = 0; i < this._members.length; ++i) {\n        total += this._members[i].typeSize();\n      }\n\n      return total;\n    }\n\n    encodeHex(): string {\n      let offset: u64 = 0;\n      for (let i = 0; i < this._members.length; ++i) {\n        offset += this._members[i].typeSize();\n      }\n\n      let res = '';\n      let tail = '';\n\n      for (let i = 0; i < this._members.length; ++i) {\n        const m = this._members[i];\n        const val = m.encodeHex();\n        if (m.isDynamicType()) {\n          res += Number.fromU64(offset).encodeHex();\n          tail += val;\n          offset += val.length >> 1;\n        } else {\n          res += val;\n        }\n      }\n\n      return res + tail;\n    }\n\n    encodeUint8Array(): Uint8Array {\n      return hexToUint8Array(this.encodeHex());\n    }\n  }\n}\n","import { AString, AUint8Array } from '../common';\n\ndeclare namespace __RuntimeContextApi__ {\n  function get(ctxKey: i32): i32;\n}\n\nexport class RuntimeContextApi {\n  private static _instance: RuntimeContextApi | null;\n\n  private constructor() {}\n\n  public static instance(): RuntimeContextApi {\n    if (!this._instance) {\n      this._instance = new RuntimeContextApi();\n    }\n    return this._instance!;\n  }\n\n  public get(key: string): Uint8Array {\n    const inputKey = new AString();\n    inputKey.set(key);\n    const inPtr = inputKey.store();\n    const ret = __RuntimeContextApi__.get(inPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n}\n","import { Protobuf } from 'as-proto/assembly';\nimport { uint8ArrayToHex } from '../../common';\nimport { RuntimeContextApi } from '../../hostapi';\nimport { BytesData, UintData } from '../../proto';\n\nconst runtimeContextApi = RuntimeContextApi.instance();\n\nexport class AspectContext {\n  private static _instance: AspectContext | null;\n\n  private constructor() {}\n\n  public get id(): string {\n    const raw = runtimeContextApi.get('aspect.id');\n    const id = Protobuf.decode<BytesData>(raw, BytesData.decode).data;\n    return uint8ArrayToHex(id);\n  }\n\n  public get version(): u64 {\n    const raw = runtimeContextApi.get('aspect.version');\n    return Protobuf.decode<UintData>(raw, UintData.decode).data;\n  }\n\n  public static instance(): AspectContext {\n    if (!this._instance) {\n      this._instance = new AspectContext();\n    }\n    return this._instance!;\n  }\n}\n","import { AString, AUint8Array, uint8ArrayToHex } from '../common';\nimport { UtilApi } from './util-api';\n\ndeclare namespace __AspectStateApi__ {\n  function get(key: i32): i32;\n\n  function set(key: i32, value: i32): void;\n}\n\nexport class AspectStateApi {\n  private static _instance: AspectStateApi | null;\n\n  private constructor() {}\n\n  public static instance(): AspectStateApi {\n    if (!this._instance) {\n      this._instance = new AspectStateApi();\n    }\n    return this._instance!;\n  }\n\n  public get(key: string): Uint8Array {\n    const inputKey = new AString();\n    inputKey.set(key);\n    const inPtr = inputKey.store();\n    const ret = __AspectStateApi__.get(inPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n\n  public set(key: string, value: Uint8Array): void {\n    const inputKey = new AString();\n    inputKey.set(key);\n    const keyPtr = inputKey.store();\n    const inputValue = new AUint8Array();\n    inputValue.set(value);\n    const valPtr = inputValue.store();\n\n    __AspectStateApi__.set(keyPtr, valPtr);\n  }\n}\n","import { fromUint8Array, toUint8Array } from '../../common';\nimport { AspectStateApi } from '../../hostapi';\nimport { ImmutableAspectValue, MutableAspectValue } from './aspect-state-interface';\n\nconst stateApi = AspectStateApi.instance();\n\nexport class MutableAspectState {\n  private static _instance: MutableAspectState | null;\n\n  private constructor() {}\n\n  public get<T>(key: string): MutableStateValue<T> {\n    return new MutableStateValue<T>(key);\n  }\n\n  public static instance(): MutableAspectState {\n    if (!this._instance) {\n      this._instance = new MutableAspectState();\n    }\n    return this._instance!;\n  }\n}\n\nexport class ImmutableAspectState {\n  private static _instance: ImmutableAspectState | null;\n\n  private constructor() {}\n\n  public get<T>(key: string): ImmutableStateValue<T> {\n    return new ImmutableStateValue<T>(key);\n  }\n\n  public static instance(): ImmutableAspectState {\n    if (!this._instance) {\n      this._instance = new ImmutableAspectState();\n    }\n    return this._instance!;\n  }\n}\n\nexport class ImmutableStateValue<T> implements ImmutableAspectValue<T> {\n  protected val: T;\n  protected loaded: boolean = false;\n\n  constructor(protected readonly key: string) {\n    this.val = fromUint8Array<T>(new Uint8Array(0));\n  }\n\n  reload(): void {\n    this.val = fromUint8Array<T>(stateApi.get(this.key));\n    this.loaded = true;\n  }\n\n  unwrap(): T {\n    if (!this.loaded) {\n      this.reload();\n    }\n\n    return this.val;\n  }\n}\n\nexport class MutableStateValue<T> extends ImmutableStateValue<T> implements MutableAspectValue<T> {\n  set<T>(value: T): void {\n    stateApi.set(this.key, toUint8Array<T>(value));\n    this.loaded = false;\n  }\n}\n","import { AString, AUint8Array } from '../common';\n\ndeclare namespace __AspectPropertyApi__ {\n  function get(key: i32): i32;\n}\n\nexport class AspectPropertyApi {\n  private static _instance: AspectPropertyApi | null;\n\n  private constructor() {}\n\n  public static instance(): AspectPropertyApi {\n    if (!this._instance) {\n      this._instance = new AspectPropertyApi();\n    }\n    return this._instance!;\n  }\n\n  public get(key: string): Uint8Array {\n    const inputKey = new AString();\n    inputKey.set(key);\n    const keyPtr = inputKey.store();\n    const ret = __AspectPropertyApi__.get(keyPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n}\n","import { fromUint8Array } from '../../common';\nimport { AspectPropertyApi } from '../../hostapi';\n\nconst propertyApi = AspectPropertyApi.instance();\n\nexport class AspectProperty {\n  private static _instance: AspectProperty | null;\n\n  private constructor() {}\n\n  public get<T>(key: string): T {\n    return fromUint8Array<T>(propertyApi.get(key));\n  }\n\n  public static instance(): AspectProperty {\n    if (!this._instance) {\n      this._instance = new AspectProperty();\n    }\n    return this._instance!;\n  }\n}\n","import { AString, AUint8Array } from '../common';\n\ndeclare namespace __AspectTransientStorageApi__ {\n  function get(aspectId: i32, key: i32): i32;\n\n  function set(key: i32, value: i32): void;\n}\n\nexport class AspectTransientStorageApi {\n  private static _instance: AspectTransientStorageApi | null;\n\n  private constructor() {}\n\n  public static instance(): AspectTransientStorageApi {\n    if (!this._instance) {\n      this._instance = new AspectTransientStorageApi();\n    }\n    return this._instance!;\n  }\n\n  public get(key: string, aspectId: Uint8Array = new Uint8Array(0)): Uint8Array {\n    const inputAspectId = new AUint8Array();\n    inputAspectId.set(aspectId);\n    const aspectIdPtr = inputAspectId.store();\n    const inputKey = new AString();\n    inputKey.set(key);\n    const inPtr = inputKey.store();\n    const ret = __AspectTransientStorageApi__.get(aspectIdPtr, inPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n\n  public set(key: string, value: Uint8Array): void {\n    const inputKey = new AString();\n    inputKey.set(key);\n    const keyPtr = inputKey.store();\n    const inputValue = new AUint8Array();\n    inputValue.set(value);\n    const valPtr = inputValue.store();\n\n    __AspectTransientStorageApi__.set(keyPtr, valPtr);\n  }\n}\n","import { fromUint8Array, hexToUint8Array, toUint8Array } from '../../common';\nimport { AspectTransientStorageApi } from '../../hostapi';\nimport { MutableAspectValue } from './aspect-state-interface';\n\nconst transientStorageApi = AspectTransientStorageApi.instance();\n\nexport class TransientStorage {\n  private static _instance: TransientStorage | null;\n\n  private constructor() {}\n\n  public get<T>(key: string, aspectId: string = ''): TransientStorageValue<T> {\n    return new TransientStorageValue(key, hexToUint8Array(aspectId));\n  }\n\n  public static instance(): TransientStorage {\n    if (!this._instance) {\n      this._instance = new TransientStorage();\n    }\n    return this._instance!;\n  }\n}\n\nexport class TransientStorageValue<T> implements MutableAspectValue<T> {\n  private val: T;\n  private loaded: boolean = false;\n\n  constructor(\n    private readonly key: string,\n    private readonly aspectId: Uint8Array = new Uint8Array(0),\n  ) {\n    this.val = fromUint8Array<T>(new Uint8Array(0));\n  }\n\n  set<T>(value: T): void {\n    transientStorageApi.set(this.key, toUint8Array<T>(value));\n    this.loaded = false;\n  }\n\n  reload(): void {\n    this.val = fromUint8Array<T>(transientStorageApi.get(this.key, this.aspectId));\n    this.loaded = true;\n  }\n\n  unwrap(): T {\n    if (!this.loaded) {\n      this.reload();\n    }\n\n    return this.val;\n  }\n}\n","import {\n  AspectContext,\n  AspectProperty,\n  ImmutableAspectState,\n  MutableAspectState,\n  TransientStorage,\n} from './components';\nimport {\n  AspectPropertyApi,\n  AspectStateApi,\n  AspectTransientStorageApi,\n  CryptoApi,\n  EvmCallApi,\n  RuntimeContextApi,\n  StateDbApi,\n  TraceApi,\n  UtilApi,\n} from './hostapi';\n\nexport namespace sys {\n  export function require(condition: bool, message: string = ''): void {\n    if (!condition) {\n      UtilApi.instance().revert(message);\n    }\n  }\n  export function revert(message: string): void {\n    UtilApi.instance().revert(message);\n  }\n  export function log(data: string): void {\n    UtilApi.instance().log(data);\n  }\n  export namespace hostApi {\n    export const evmCall = EvmCallApi.instance();\n    export const runtimeContext = RuntimeContextApi.instance();\n    export const crypto = CryptoApi.instance();\n    export const stateDb = StateDbApi.instance();\n    export const util = UtilApi.instance();\n\n    export const aspectState = AspectStateApi.instance();\n\n    export const aspectProperty = AspectPropertyApi.instance();\n\n    export const aspectTransientStorage = AspectTransientStorageApi.instance();\n\n    export const trace = TraceApi.instance();\n  }\n  export namespace aspect {\n    export function id(): string {\n      return AspectContext.instance().id;\n    }\n\n    export function version(): u64 {\n      return AspectContext.instance().version;\n    }\n\n    export const mutableState = MutableAspectState.instance();\n\n    export const readonlyState = ImmutableAspectState.instance();\n    export const property = AspectProperty.instance();\n\n    export const transientStorage = TransientStorage.instance();\n  }\n}\n","import { ABool, AU64, AUint8Array } from '../common';\n\ndeclare namespace __StateDbApi__ {\n  function getBalance(addr: i32): i32;\n\n  function getState(addr: i32, hash: i32): i32;\n\n  function getCodeHash(addr: i32): i32;\n\n  function getNonce(addr: i32): i32;\n\n  function getCodeSize(addr: i32): i32;\n\n  function hasSuicided(addr: i32): i32;\n}\n\nexport class StateDbApi {\n  private static _instance: StateDbApi | null;\n\n  private constructor() {}\n\n  public balance(addr: Uint8Array): Uint8Array {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n    const outPtr = __StateDbApi__.getBalance(inPtr);\n    const output = new AUint8Array();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public stateAt(addr: Uint8Array, hash: Uint8Array): Uint8Array {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n\n    const inpHash = new AUint8Array();\n    inpHash.set(hash);\n    const inHashPtr = inpHash.store();\n\n    const outPtr = __StateDbApi__.getState(inPtr, inHashPtr);\n    const output = new AUint8Array();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public codeHash(addr: Uint8Array): Uint8Array {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n\n    const outPtr = __StateDbApi__.getCodeHash(inPtr);\n    const output = new AUint8Array();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public codeSize(addr: Uint8Array): u64 {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n\n    const outPtr = __StateDbApi__.getCodeSize(inPtr);\n    const output = new AU64();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public nonce(addr: Uint8Array): u64 {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n\n    const outPtr = __StateDbApi__.getNonce(inPtr);\n    const output = new AU64();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public hasSuicided(addr: Uint8Array): bool {\n    const input = new AUint8Array();\n    input.set(addr);\n    const inPtr = input.store();\n\n    const outPtr = __StateDbApi__.hasSuicided(inPtr);\n    const output = new ABool();\n    output.load(outPtr);\n    return output.get();\n  }\n\n  public static instance(): StateDbApi {\n    if (!this._instance) {\n      this._instance = new StateDbApi();\n    }\n    return this._instance!;\n  }\n}\n","import { AString } from '../common';\n\ndeclare namespace __UtilApi__ {\n  function revert(ptr: i32): void;\n\n  function sLog(ptr: i32): void;\n}\n\nexport class UtilApi {\n  private static _instance: UtilApi | null;\n\n  private constructor() {}\n\n  public static instance(): UtilApi {\n    if (!this._instance) {\n      this._instance = new UtilApi();\n    }\n    return this._instance!;\n  }\n\n  public revert(message: string): void {\n    const input = new AString();\n    input.set(message);\n    const inPtr = input.store();\n    __UtilApi__.revert(inPtr);\n    throw new Error(message);\n  }\n\n  public log(data: string): void {\n    const dataPtr = new AString(data).store();\n    __UtilApi__.sLog(dataPtr);\n  }\n}\n","import { Protobuf } from 'as-proto/assembly';\nimport { AUint8Array } from '../common';\nimport { CallTreeQuery, StateChangeQuery } from '../proto';\n\ndeclare namespace __TraceApi__ {\n  function queryStateChange(query: i32): i32;\n  function queryCallTree(query: i32): i32;\n}\n\nexport class TraceApi {\n  private static _instance: TraceApi | null;\n\n  private constructor() {}\n\n  public static instance(): TraceApi {\n    if (!this._instance) {\n      this._instance = new TraceApi();\n    }\n    return this._instance!;\n  }\n\n  public queryStateChange(query: StateChangeQuery): Uint8Array {\n    const rawQuery = Protobuf.encode<StateChangeQuery>(query, StateChangeQuery.encode);\n    const rawRequest = new AUint8Array();\n    rawRequest.set(rawQuery);\n    const inPtr = rawRequest.store();\n    const ret = __TraceApi__.queryStateChange(inPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n\n  public queryCallTree(query: CallTreeQuery): Uint8Array {\n    const rawQuery = Protobuf.encode<CallTreeQuery>(query, CallTreeQuery.encode);\n    const rawRequest = new AUint8Array();\n    rawRequest.set(rawQuery);\n    const inPtr = rawRequest.store();\n    const ret = __TraceApi__.queryCallTree(inPtr);\n    const bytes = new AUint8Array();\n    bytes.load(ret);\n    return bytes.get();\n  }\n}\n","// multiple precision integer\nimport { sys } from '../../package';\n\nexport class BigInt {\n  private d: Uint32Array; // digits\n  private n: i32 = 0; // digits used\n  private isNeg: boolean; // sign\n  get isNegative(): boolean {\n    return this.isNeg;\n  }\n\n  // private static readonly q: i32 = 2;\n  private static readonly p: i32 = 28; // bits used in digit\n  // private static readonly b: u32 = BigInt.q ** BigInt.p; // digit basis\n  private static readonly actualBits: i32 = 32; // bits available in type (single precision)\n  // private static readonly doubleActualBits: i32 = 64 // 2 * BigIntMP.actualBits -> \"double precision\" actual bits\n  private static readonly maxComba: i32 = 256; // 2^(doubleActualBits - 2 * p) = 2^8 = 256\n\n  private static readonly digitMask: u32 = <u32>((1 << BigInt.p) - 1); // mask p least significant bits\n\n  private static readonly precision: i32 = 5; // base array size fits 140 bit integers\n\n  // private static readonly maxBits: i32 = I32.MAX_VALUE;\n  // private static readonly maxN: i32 = BigInt.maxBits / BigInt.p;\n\n  // CONSTRUCTORS //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private constructor(size: i32 = BigInt.precision, isNegative: boolean = false) {\n    this.d = new Uint32Array(size);\n    this.isNeg = isNegative;\n  }\n\n  // generic constructor based on https://github.com/ttulka/as-big/blob/main/assembly/Big.ts#L84\n  /**\n   * Returns a new {BigInt} instance from generic type {T}.\n   *\n   * @param  val the number as {BigInt}, {string}, or {number}\n   * @return BigInt the new {BigInt} instance\n   */\n  static from<T>(val: T): BigInt {\n    if (val instanceof BigInt) return val;\n    if (val instanceof string) return BigInt.fromString(val);\n    if (val instanceof i8) return BigInt.fromInt16(<i16>val);\n    if (val instanceof u8) return BigInt.fromUInt16(<u16>val);\n    if (val instanceof i16) return BigInt.fromInt16(val);\n    if (val instanceof u16) return BigInt.fromUInt16(val);\n    if (val instanceof i32) return BigInt.fromInt32(val);\n    if (val instanceof u32) return BigInt.fromUInt32(val);\n    if (val instanceof i64) return BigInt.fromInt64(val);\n    if (val instanceof u64) return BigInt.fromUInt64(val);\n\n    throw new TypeError('Unsupported generic type ' + nameof<T>(val));\n  }\n\n  static fromUint8Array(bytes: Uint8Array, isNegative: boolean = false): BigInt {\n    const res = new BigInt((bytes.length + <i32>3) / <i32>4, isNegative);\n    let digit: u32 = 0;\n    let shift: u8 = 0;\n\n    for (let i = 0; i < bytes.length; ++i) {\n      digit |= (<u32>bytes[i]) << shift;\n      shift += 8;\n      if (shift === 32) {\n        res.d[res.n++] = digit;\n        digit = 0;\n        shift = 0;\n      }\n    }\n\n    if (shift > 0) {\n      res.d[res.n++] = digit;\n    }\n\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  toUint8Array(): Uint8Array {\n    const byteArray = new Uint8Array(this.n * 4);\n    let byteIndex = 0;\n\n    for (let i = 0; i < this.n; ++i) {\n      const digit = this.d[i];\n      for (let shift = 0; shift < 32; shift += 8) {\n        byteArray[byteIndex++] = (digit >> shift) & 0xff;\n      }\n    }\n\n    return byteArray;\n  }\n\n  toUint8ArrayWithSign(): Uint8Array {\n    const byteArray = new Uint8Array(this.n * 4 + 1);\n    byteArray[0] = this.isNeg ? 0xff : 0x00;\n\n    let byteIndex = 1;\n    for (let i = 0; i < this.n; ++i) {\n      const digit = this.d[i];\n      for (let shift = 0; shift < 32; shift += 8) {\n        byteArray[byteIndex++] = (digit >> shift) & 0xff;\n      }\n    }\n\n    return byteArray;\n  }\n\n  static fromUint8ArrayWithSign(bytes: Uint8Array): BigInt {\n    if (bytes.length === 0) {\n      return BigInt.ZERO;\n    }\n    const isNegative = bytes[0] === 0xff;\n    return this.fromUint8Array(bytes.subarray(1), isNegative);\n  }\n\n  static fromString(bigInteger: string, radix: i32 = 10): BigInt {\n    if (radix < 2 || radix > 16) {\n      throw new RangeError('BigInt only reads strings of radix 2 through 16');\n    }\n    let i: i32 = 0;\n    let isNegative = false;\n    if (bigInteger.charAt(0) == '-') {\n      i++;\n      isNegative = true;\n    }\n    if (\n      (radix == 16 || radix == 10) &&\n      bigInteger.charAt(i) == '0' &&\n      bigInteger.charAt(i + 1) == 'x'\n    ) {\n      i += 2;\n      radix = 16;\n    }\n    let res: BigInt = BigInt.fromUInt16(0);\n    const radixU: u16 = <u16>radix;\n    for (; i < bigInteger.length; i++) {\n      const code: i32 = bigInteger.charCodeAt(i);\n      let val: u16;\n      if (code >= 48 && code <= 57) {\n        val = <u16>(code - 48);\n      } else if (code >= 65 && code <= 70) {\n        val = <u16>(code - 55);\n      } else if (code >= 97 && code <= 102) {\n        val = <u16>(code - 87);\n      } else {\n        throw new RangeError(\n          'Character ' + bigInteger.charAt(i) + ' is not supported for radix ' + radix.toString(),\n        );\n      }\n      res = res.inplaceMulInt(radixU).add(BigInt.fromUInt16(val));\n    }\n    res.isNeg = isNegative;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromUInt16(val: u16): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    res.d[0] = (<u32>val) & BigInt.digitMask;\n    res.n = res.d[0] == 0 ? 0 : 1;\n    return res;\n  }\n\n  static fromUInt32(val: u32): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    let i = 0;\n    while (val != 0) {\n      res.d[i++] = val & BigInt.digitMask;\n      val >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromUInt64(val: u64): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    let i = 0;\n    while (val != 0) {\n      res.d[i++] = (<u32>val) & BigInt.digitMask;\n      val >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromInt16(val: i16): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    const unsignedDigit: u16 = <u16>(isNeg ? -1 * val : val);\n    res.d[0] = (<u32>unsignedDigit) & BigInt.digitMask;\n    res.n = res.d[0] == 0 ? 0 : 1;\n    return res;\n  }\n\n  static fromInt32(val: i32): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    let unsignedDigit: u32 = <u32>(isNeg ? -1 * val : val);\n    let i = 0;\n    while (unsignedDigit != 0) {\n      res.d[i++] = unsignedDigit & BigInt.digitMask;\n      unsignedDigit >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromInt64(val: i64): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    let unsignedDigit: u64 = <u64>(isNeg ? -1 * val : val);\n    let i = 0;\n    while (unsignedDigit != 0) {\n      res.d[i++] = (<u32>unsignedDigit) & BigInt.digitMask;\n      unsignedDigit >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // O(N)\n  private static fromDigits(\n    digits: Uint32Array,\n    isNegative: boolean = false,\n    n: i32 = digits.length,\n    minSize: i32 = digits.length,\n  ): BigInt {\n    let size = minSize;\n    if (size < digits.length) {\n      size = digits.length;\n    }\n    const extra = size % BigInt.precision;\n    if (extra != 0) {\n      size += BigInt.precision - extra;\n    }\n    const res: BigInt = new BigInt(size, isNegative);\n    for (let i = 0; i < digits.length; i++) {\n      res.d[i] = digits[i];\n    }\n    res.n = n;\n    return res;\n  }\n\n  // O(N)\n  copy(): BigInt {\n    return BigInt.fromDigits(this.d, this.isNeg, this.n);\n  }\n\n  // O(N)\n  opposite(): BigInt {\n    return BigInt.fromDigits(this.d, this.n > 0 && !this.isNeg, this.n);\n  }\n\n  // O(N)\n  abs(): BigInt {\n    return BigInt.fromDigits(this.d, false, this.n);\n  }\n\n  private static getEmptyResultContainer(minSize: i32, isNegative: boolean, n: i32): BigInt {\n    const size: i32 = minSize + BigInt.precision - (minSize % BigInt.precision);\n    const res: BigInt = new BigInt(size, isNegative);\n    res.n = n;\n    return res;\n  }\n\n  // MAINTENANCE FUNCTIONS /////////////////////////////////////////////////////////////////////////////////////////////\n\n  private trimLeadingZeros(): void {\n    while (this.n > 0 && this.d[this.n - 1] == 0) {\n      this.n--;\n    }\n    if (this.n == 0) {\n      this.isNeg = false;\n    }\n  }\n\n  private resize(max: i32): void {\n    const temp: Uint32Array = new Uint32Array(max);\n    for (let i = 0; i < this.n; i++) {\n      temp[i] = this.d[i];\n    }\n    this.d = temp;\n  }\n\n  private grow(size: i32): void {\n    if (this.d.length >= size) return;\n    this.resize(size + 2 * BigInt.precision - (size % BigInt.precision));\n  }\n\n  // OUTPUT /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toString(radix: i32 = 10): string {\n    if (radix < 2 || radix > 16) {\n      throw new RangeError('BigInt only prints strings in radix 2 through 16');\n    }\n    if (this.n == 0) return '0';\n    let res: string = this.isNeg ? '-' : '';\n    let t: BigInt = this.abs();\n    const zero: BigInt = BigInt.fromUInt16(0);\n    const codes: i32[] = [];\n    const radixU: u32 = <u32>radix;\n    while (t.ne(zero)) {\n      const d: i32 = <i32>t.modInt(radixU);\n      t = t.inplaceDivInt(radixU);\n      if (d < 10) {\n        codes.push(d + 48);\n      } else {\n        codes.push(d + 87);\n      }\n    }\n    codes.reverse();\n    res += String.fromCharCodes(codes);\n    return res;\n  }\n\n  toInt8(): i8 {\n    if (this.n == 0) return 0;\n    const bitCount = this.countBits();\n    if (bitCount > 8)\n      throw new Error(`Integer overflow: cannot output i8 from a BigInt with ${bitCount} bits`);\n\n    const result = <i8>(this.d[0] & 0xff);\n    return this.isNeg ? -result : result;\n  }\n\n  toInt16(): i16 {\n    if (this.n == 0) return 0;\n    const bitCount = this.countBits();\n    if (bitCount > 16)\n      throw new Error(`Integer overflow: cannot output i16 from a BigInt with ${bitCount} bits`);\n\n    const result = <i16>(this.d[0] & 0xff_ff);\n    return this.isNeg ? -result : result;\n  }\n\n  toInt32(): i32 {\n    if (this.n <= 1) {\n      return this.n == 0 ? <i32>0 : <i32>this.d[0] * (this.isNeg ? -1 : 1);\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 32) {\n      throw new Error(\n        `Integer overflow: cannot output i32 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    const biString: string = this.toString();\n    const result: i32 = I32.parseInt(biString);\n    if (bitCount == 32 && result.toString() != biString) {\n      throw new Error('Signed integer overflow');\n    }\n    return result;\n  }\n\n  toInt64(): i64 {\n    if (this.n <= 1) {\n      return this.n == 0 ? <i64>0 : <i64>this.d[0] * (this.isNeg ? -1 : 1);\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 64) {\n      throw new Error(\n        `Integer overflow: cannot output i64 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    const biString: string = this.toString();\n    const result: i64 = I64.parseInt(biString);\n    if (bitCount == 64 && result.toString() != biString) {\n      throw new Error('Signed integer overflow');\n    }\n    return result;\n  }\n\n  toUInt8(): u8 {\n    if (this.isNeg) throw new Error('Cannot cast negative integer to u8');\n    if (this.n == 0) return 0;\n\n    const bitCount = this.countBits();\n    if (bitCount > 8)\n      throw new Error(`Integer overflow: cannot output u8 from a BigInt with ${bitCount} bits`);\n\n    return <u8>(this.d[0] & 0xff);\n  }\n\n  toUInt16(): u16 {\n    if (this.isNeg) throw new Error('Cannot cast negative integer to u16');\n    if (this.n == 0) return 0;\n\n    const bitCount = this.countBits();\n    if (bitCount > 16)\n      throw new Error(`Integer overflow: cannot output u16 from a BigInt with ${bitCount} bits`);\n\n    return <u16>(this.d[0] & 0xff_ff);\n  }\n\n  toUInt32(): u32 {\n    if (this.isNeg) {\n      throw new Error('Cannot cast negative integer to u32');\n    }\n    if (this.n <= 1) {\n      return this.n == 0 ? <u32>0 : <u32>this.d[0];\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 32) {\n      throw new Error(\n        `Integer overflow: cannot output u32 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    return U32.parseInt(this.toString());\n  }\n\n  toUInt64(): u64 {\n    if (this.isNeg) {\n      throw new Error('Cannot cast negative integer to u64');\n    }\n    if (this.n <= 1) {\n      return this.n == 0 ? <u64>0 : <u64>this.d[0];\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 64) {\n      throw new Error(\n        `Integer overflow: cannot output u64 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    return U64.parseInt(this.toString());\n  }\n\n  // COMPARISON OPERATORS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  eq<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) == 0;\n  }\n\n  ne<T>(other: T): boolean {\n    return !this.eq(BigInt.from(other));\n  }\n\n  lt<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) < 0;\n  }\n\n  lte<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) <= 0;\n  }\n\n  gt<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) > 0;\n  }\n\n  gte<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) >= 0;\n  }\n\n  compareTo(other: BigInt): i32 {\n    // opposite signs\n    if (this.isNeg && !other.isNeg) {\n      return -1;\n    }\n    if (!this.isNeg && other.isNeg) {\n      return 1;\n    }\n    if (this.isNeg) {\n      return other.magCompareTo(this);\n    }\n    return this.magCompareTo(other);\n  }\n\n  magCompareTo(other: BigInt): i32 {\n    if (this.n > other.n) return 1;\n    if (this.n < other.n) return -1;\n    for (let i = this.n - 1; i >= 0; i--) {\n      if (this.d[i] != other.d[i]) {\n        if (this.d[i] < other.d[i]) return -1;\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n  // CORE MATH OPERATIONS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  // signed addition\n  add<T>(other: T): BigInt {\n    const addend: BigInt = BigInt.from(other);\n    if (this.isNeg == addend.isNeg) {\n      return this._add(addend, this.isNeg);\n    }\n    if (this.magCompareTo(addend) < 0) {\n      return addend._sub(this, addend.isNeg);\n    }\n    return this._sub(addend, this.isNeg);\n  }\n\n  // signed subtraction\n  sub<T>(other: T): BigInt {\n    const subtrahend: BigInt = BigInt.from(other);\n    if (this.isNeg != subtrahend.isNeg) {\n      return this._add(subtrahend, this.isNeg);\n    }\n    if (this.magCompareTo(subtrahend) >= 0) {\n      return this._sub(subtrahend, this.isNeg);\n    }\n    return subtrahend._sub(this, !this.isNeg);\n  }\n\n  // unsigned addition\n  private _add(other: BigInt, resultIsNegative: boolean): BigInt {\n    // determine which summand is larger\n    let min: i32;\n    let max: i32;\n    let x: BigInt;\n    if (this.n > other.n) {\n      min = other.n;\n      max = this.n;\n      x = this;\n    } else {\n      min = this.n;\n      max = other.n;\n      x = other;\n    }\n    // initialize result\n    const res: BigInt = BigInt.getEmptyResultContainer(max + 1, resultIsNegative, max);\n    // add\n    let carry: u32 = 0;\n    let i: i32 = 0;\n    for (; i < min; i++) {\n      res.d[i] = this.d[i] + other.d[i] + carry;\n      carry = res.d[i] >> BigInt.p;\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (min != max) {\n      for (; i < max; i++) {\n        res.d[i] = x.d[i] + carry;\n        carry = res.d[i] >> BigInt.p;\n        res.d[i] &= BigInt.digitMask;\n      }\n    }\n    if (carry > 0) {\n      res.d[max] = carry;\n      res.n++;\n    }\n    return res;\n  }\n\n  // unsigned subtraction\n  private _sub(other: BigInt, resultIsNegative: boolean): BigInt {\n    const min: i32 = other.n;\n    const max: i32 = this.n;\n    // initialize result\n    const res: BigInt = BigInt.getEmptyResultContainer(max, resultIsNegative, max);\n    // subtract\n    let carry: u32 = 0;\n    let i: i32 = 0;\n    for (; i < min; i++) {\n      res.d[i] = this.d[i] - other.d[i] - carry;\n      carry = res.d[i] >> (BigInt.actualBits - 1);\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (min < max) {\n      for (; i < max; i++) {\n        res.d[i] = this.d[i] - carry;\n        carry = res.d[i] >> (BigInt.actualBits - 1);\n        res.d[i] &= BigInt.digitMask;\n      }\n    }\n    // trim and return\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // unsigned addition of 1\n  private _addOne(resultIsNegative: boolean): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n + 1, resultIsNegative, this.n);\n    let carry = 1;\n    for (let i = 0; i < this.n; i++) {\n      res.d[i] = this.d[i] + carry;\n      carry = res.d[i] >> BigInt.p;\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (carry > 0) {\n      res.d[this.n] = carry;\n      res.n++;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // unsigned subtraction of 1\n  private _subOne(resultIsNegative: boolean): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n, resultIsNegative, this.n);\n    let carry = 1;\n    for (let i = 0; i < this.n; i++) {\n      res.d[i] = this.d[i] - carry;\n      carry = res.d[i] >> (BigInt.actualBits - 1);\n      res.d[i] &= BigInt.digitMask;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // efficient multiply by 2\n  mul2(): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n + 1, this.isNeg, this.n);\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u32 = this.d[i] >> (BigInt.p - 1);\n      res.d[i] = ((this.d[i] << 1) | r) & BigInt.digitMask;\n      r = rr;\n    }\n    if (r != 0) {\n      res.d[res.n++] = 1;\n    }\n    return res;\n  }\n\n  // efficient div by 2\n  div2(): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n, this.isNeg, this.n);\n    let r: u32 = 0;\n    for (let i = this.n - 1; i >= 0; i--) {\n      const rr: u32 = this.d[i] % 2;\n      res.d[i] = (this.d[i] >> 1) | (r << (BigInt.p - 1));\n      r = rr;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // multiples BigInt by power of basis\n  // *** mutates BigInt ***\n  private mulBasisPow(b: i32): void {\n    if (b <= 0) return;\n    this.grow(this.n + b);\n    this.n += b;\n    let i: i32 = this.n - 1;\n    let j: i32 = this.n - 1 - b;\n    for (; i >= b; i--, j--) {\n      this.d[i] = this.d[j];\n    }\n    for (; i >= 0; i--) {\n      this.d[i] = 0;\n    }\n  }\n\n  // divides BigInt by power of basis\n  // *** mutates BigInt ***\n  private divBasisPow(b: i32): void {\n    if (b <= 0) return;\n    // integer division with denominator > numerator = 0\n    if (this.n <= b) {\n      this.n = 0;\n      this.trimLeadingZeros();\n      return;\n    }\n    // division\n    let i: i32 = 0;\n    let j: i32 = b;\n    for (; i < this.n - b; i++, j++) {\n      this.d[i] = this.d[j];\n    }\n    for (; i < this.n; i++) {\n      this.d[i] = 0;\n    }\n    this.n -= b;\n  }\n\n  // multiply by power of 2\n  // O(2N)\n  mulPowTwo(k: i32): BigInt {\n    if (k <= 0) {\n      return this.copy();\n    }\n    const minSize: i32 = this.n + k / BigInt.p + 1;\n    const res = BigInt.fromDigits(this.d, this.isNeg, this.n, minSize);\n    // shift by entire digits\n    if (k >= BigInt.p) {\n      res.mulBasisPow(k / BigInt.p);\n    }\n    // shift by k % p bits\n    const remK: i32 = k % BigInt.p;\n    if (remK != 0) {\n      const mask: u32 = <u32>((1 << remK) - 1);\n      const shift: i32 = BigInt.p - remK;\n      let r: u32 = 0;\n      for (let i = 0; i < res.n; i++) {\n        const rr: u32 = (res.d[i] >> shift) & mask;\n        res.d[i] = ((res.d[i] << remK) | r) & BigInt.digitMask;\n        r = rr;\n      }\n      if (r != 0) {\n        res.d[res.n++] = r;\n      }\n    }\n    return res;\n  }\n\n  // divide by power of 2\n  divPowTwo(k: i32): BigInt {\n    const res = this.copy();\n    if (k <= 0) {\n      return res;\n    }\n    if (k >= BigInt.p) {\n      res.divBasisPow(k / BigInt.p);\n    }\n    const remK: i32 = k % BigInt.p;\n    if (remK != 0) {\n      const mask: u32 = <u32>((1 << remK) - 1);\n      const shift: i32 = BigInt.p - remK;\n      let r: u32 = 0;\n      for (let i = res.n - 1; i >= 0; i--) {\n        const rr: u32 = res.d[i] & mask;\n        res.d[i] = (res.d[i] >> remK) | (r << shift);\n        r = rr;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // remainder of division by power of 2\n  modPowTwo(k: i32): BigInt {\n    if (k == 0) {\n      return BigInt.fromUInt16(<u16>0);\n    }\n    const res = this.copy();\n    // if 2^k > BigInt, then BigInt % 2^k == BigInt\n    if (k > this.n * BigInt.p) {\n      return res;\n    }\n    // zero out unused digits (any digit greater than 2^b)\n    const kDivP: i32 = k / BigInt.p;\n    let i: i32 = kDivP + (k % BigInt.p) == 0 ? 0 : 1; // ceil of k / p\n    for (; i < res.n; i++) {\n      res.d[i] = 0;\n    }\n    // mod the remaining leading digit (which includes 2^b) using bitmask\n    // remK = k % BigIntMP.p\n    res.d[kDivP] &= ((<u32>1) << k % BigInt.p) - <u32>1;\n    // trim and return\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // left bit shift\n  leftShift(k: i32): BigInt {\n    if (k == 0) return this.copy();\n    if (k < 0) return this.rightShiftByAbsolute(k);\n    return this.leftShiftByAbsolute(k);\n  }\n\n  // signed right bit shift\n  rightShift(k: i32): BigInt {\n    if (k == 0) return this.copy();\n    if (k < 0) return this.leftShiftByAbsolute(k);\n    return this.rightShiftByAbsolute(k);\n  }\n\n  private leftShiftByAbsolute(k: i32): BigInt {\n    return this.mulPowTwo(k >>> 0);\n  }\n\n  private rightShiftByAbsolute(k: i32): BigInt {\n    const shift: i32 = k >>> 0;\n    // shift by max if result would equal 0\n    if (this.n - shift / BigInt.p <= 0) {\n      return BigInt.rightShiftByMaximum(this.isNeg);\n    }\n    // arithmetic shift\n    const res: BigInt = this.divPowTwo(shift);\n    // for negative numbers, round down if a bit would be shifted out\n    // Since the result is negative, rounding down means adding one to its absolute value. This cannot overflow.\n    if (this.rightShiftMustRoundDown(shift)) {\n      return res._addOne(true);\n    }\n    return res;\n  }\n\n  // For negative numbers, round down if any bit was shifted out (so that\n  // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n  // and whether it can cause overflow into a new digit. If we allocate the\n  // result large enough up front, it avoids having to do grow it later.\n  private rightShiftMustRoundDown(k: i32): boolean {\n    if (this.isNeg) {\n      const digitShift: i32 = k / BigInt.p;\n      const remK: i32 = k % BigInt.p;\n      const mask: u32 = <u32>((1 << remK) - 1);\n      if ((this.d[digitShift] & mask) != 0) {\n        return true;\n      }\n      for (let i = 0; i < digitShift; i++) {\n        if (this.d[i] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private static rightShiftByMaximum(isNeg: boolean): BigInt {\n    if (isNeg) {\n      return BigInt.NEG_ONE;\n    }\n    return BigInt.ZERO;\n  }\n\n  // MULTIPLICATION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // chooses best multiplication algorithm for situation and handles sign\n  mul<T>(other: T): BigInt {\n    const multiplier: BigInt = BigInt.from(other);\n    let res: BigInt;\n    const digitsNeeded: i32 = this.n + multiplier.n + 1;\n    const minN: i32 = this.n <= multiplier.n ? this.n : multiplier.n;\n    if (digitsNeeded < BigInt.maxComba && minN < BigInt.maxComba) {\n      res = this._mulComba(multiplier, digitsNeeded);\n    } else {\n      res = this._mulPartial(multiplier, digitsNeeded);\n    }\n    res.isNeg = this.isNeg != multiplier.isNeg && res.n > 0;\n    return res;\n  }\n\n  // unsigned multiplication that returns at most maxDigits\n  private _mulPartial(other: BigInt, maxDigits: i32): BigInt {\n    // const min: i32 = this.n <= other.n ? this.n : other.n;\n    // optimization -> use Comba multiplication if possible\n    // if (maxDigits < BigInt.maxComba && min < BigInt.maxComba) {\n    //   return this._mulComba(other, maxDigits);\n    // }\n    const res = BigInt.getEmptyResultContainer(maxDigits, false, maxDigits);\n    // multiply using standard O(N^2) method taught in schools\n    for (let i = 0; i < this.n; i++) {\n      let r: u32 = 0;\n      const digsSubI: i32 = maxDigits - i;\n      const limitedN: i32 = other.n < digsSubI ? other.n : digsSubI;\n      for (let j = 0; j < limitedN; j++) {\n        const rr: u64 = <u64>res.d[i + j] + <u64>this.d[i] * other.d[j] + r;\n        res.d[i + j] = <u32>(rr & (<u64>BigInt.digitMask));\n        r = <u32>(rr >> BigInt.p);\n      }\n      if (i + limitedN < maxDigits) {\n        res.d[i + limitedN] = r;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // fast unsigned multiplication using Comba method\n  private _mulComba(other: BigInt, maxDigits: i32): BigInt {\n    const totalN = this.n + other.n;\n    const outerN: i32 = maxDigits < totalN ? maxDigits : totalN; // number of output digits to produce\n    const res = BigInt.getEmptyResultContainer(outerN, false, outerN);\n    let w: u64 = 0;\n    // multiply, ignoring carries\n    for (let i = 0; i < outerN; i++) {\n      // calculate tY and tX, offsets into the multiplicands\n      const maxJ: i32 = other.n - 1;\n      const tY: i32 = maxJ < i ? maxJ : i;\n      const tX: i32 = i - tY;\n      // calculate innerN, the number of times inner loop will iterate\n      const distFromEnd: i32 = this.n - tX;\n      const currentN: i32 = tY + 1;\n      const innerN: i32 = distFromEnd < currentN ? distFromEnd : currentN;\n      for (let j = 0; j < innerN; j++) {\n        w += <u64>this.d[tX + j] * other.d[tY - j];\n      }\n      res.d[i] = (<u32>w) & BigInt.digitMask;\n      w = w >> BigInt.p;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // EXPONENTIATION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  pow<T>(val: T): BigInt {\n    if (val instanceof BigInt) return this._powBigint(val);\n    if (val instanceof string) return this._powBigint(BigInt.from(val));\n    if (isInteger(val)) return this._powInt(val);\n    throw new TypeError('Unsupported generic type ' + nameof<T>(val));\n  }\n\n  private _powBigint(k: BigInt): BigInt {\n    if (k.isNeg) {\n      throw new RangeError('BigInt does not support negative exponentiation');\n    }\n    if (k.lte(BigInt.fromUInt64(u64.MAX_VALUE))) {\n      return this._powInt(k.toUInt64());\n    }\n    let temp: BigInt = this.copy();\n    let res: BigInt = BigInt.ONE;\n    while (k.lt(BigInt.ZERO)) {\n      /* if the bit is set multiply */\n      if (k.bitwiseAnd(1).ne(0)) res = res.mul(temp);\n      /* square */\n      if (k.gt(BigInt.ONE)) temp = temp.square();\n      /* shift to next bit */\n      k = k.rightShift(1);\n    }\n    return res;\n  }\n\n  private _powInt<T>(k: T): BigInt {\n    if (k < 0) {\n      throw new RangeError('BigInt does not support negative exponentiation');\n    }\n    let temp: BigInt = this.copy();\n    let res: BigInt = BigInt.ONE;\n    while (k > 0) {\n      /* if the bit is set multiply */\n      if ((k & 1) != 0) res = res.mul(temp);\n      /* square */\n      if (k > 1) temp = temp.square();\n      /* shift to next bit */\n      k >>= 1;\n    }\n    return res;\n  }\n\n  square(): BigInt {\n    const digitsNeeded: i32 = this.n + this.n + 1;\n    if (digitsNeeded < BigInt.maxComba) {\n      return this._squareComba();\n    }\n    return this._baseSquare();\n  }\n\n  private _baseSquare(): BigInt {\n    const size: i32 = this.n + this.n + 1;\n    const res = BigInt.getEmptyResultContainer(size, false, size);\n    for (let i = 0; i < size; i++) {\n      let j: i32;\n      // first calculate the digit at 2*i and the double precision result\n      let r: u64 = <u64>this.d[i] * this.d[i] + res.d[i + i];\n      // store lower part in result\n      res.d[i + i] = <u32>(r & BigInt.digitMask);\n      // get the carry\n      let u: u32 = <u32>(r >> BigInt.p);\n      for (j = i + 1; j < size; j++) {\n        // first calculate the product\n        r = <u64>this.d[i] * this.d[j];\n        // now calculate the double precision result\n        r = <u64>res.d[i + j] + r + r + u;\n        // store lower part\n        res.d[i + j] = <u32>(r & BigInt.digitMask);\n        // get carry\n        u = <u32>(r >> BigInt.p);\n      }\n      // propagate upwards\n      while (u != 0) {\n        r = <u64>res.d[i + j] + u;\n        res.d[i + j] = <u32>(r & BigInt.digitMask);\n        u = <u32>(r >> BigInt.p);\n        ++j;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  private _squareComba(): BigInt {\n    const size: i32 = this.n + this.n;\n    const res = BigInt.getEmptyResultContainer(size, false, size);\n\n    let u: u64 = 0;\n    for (let i = 0; i < size; i++) {\n      /* clear accumulator */\n      let accum: u64 = 0;\n      /* get offsets into the two BigInts */\n      const nSub1: i32 = this.n - 1;\n      const y: i32 = nSub1 < i ? nSub1 : i; // min\n      const x: i32 = i - y;\n      /* this is the number of times the loop will iterate, essentially\n                     while (x++ < this.n && y-- >= 0) { ... }\n                   */\n      const nSubX: i32 = this.n - x;\n      const yAdd1: i32 = y + 1;\n      let j: i32 = nSubX < yAdd1 ? nSubX : yAdd1; // min\n      /* now for squaring x can never equal y\n       * we halve the distance since they approach at a rate of 2*\n       * and we have to round because odd cases need to be executed\n       */\n      const shiftedDiff: i32 = (y - x + 1) >> 1;\n      j = j < shiftedDiff ? j : shiftedDiff;\n      /* execute loop */\n      for (let k = 0; k < j; k++) {\n        accum += <u64>this.d[x + k] * this.d[y - k];\n      }\n      /* double the inner product and add carry */\n      accum = accum + accum + u;\n      /* even columns have the square term in them */\n      if (((<u32>i) & 1) == 0) {\n        accum += <u64>this.d[i >> 1] * this.d[i >> 1];\n      }\n      /* store it */\n      res.d[i] = (<u32>accum) & BigInt.digitMask;\n      /* make next carry */\n      u = accum >> BigInt.p;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  sqrt(): BigInt {\n    if (this.isNeg) throw new RangeError('Square root of negative numbers is not supported');\n    if (this.n == 0) return this.copy();\n\n    // rely on built in sqrt if possible\n    if (this.lte(BigInt.fromUInt64(<u64>F64.MAX_SAFE_INTEGER))) {\n      const fVal: f64 = <f64>this.toUInt64();\n      const fSqrt: f64 = Math.floor(Math.sqrt(fVal));\n      return BigInt.fromUInt64(<u64>fSqrt);\n    }\n\n    // Newton Raphson iteration\n    let z: BigInt = this; // eslint-disable-line  @typescript-eslint/no-this-alias\n    let x: BigInt = BigInt.fromUInt16(1).mulPowTwo(this.countBits() / 2);\n    x = this.div(x).add(x).div2();\n    while (x < z) {\n      z = x;\n      x = this.div(x).add(x).div2();\n    }\n\n    return z;\n  }\n\n  log2(): BigInt {\n    if (this.lte(BigInt.ZERO)) {\n      throw new RangeError('Logarithm of non-positive numbers is not supported');\n    }\n    this.trimLeadingZeros();\n    return BigInt.from(this.countBits() - 1);\n  }\n\n  log<T>(base: T): BigInt {\n    if (base instanceof BigInt) return this._logBigint(base);\n    if (isInteger(base) || isFloat(base)) return this._logNumber(base);\n    throw new TypeError('Unsupported generic type ' + nameof<T>(base));\n  }\n\n  private _logNumber<T>(base: T): BigInt {\n    return this.log2().div(floor(Math.log2(base)));\n  }\n\n  private _logBigint(base: BigInt): BigInt {\n    return this.log2().div(base.log2());\n  }\n\n  // DIVISION //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // handles sign and allows for easy replacement of algorithm in future update\n  div<T>(other: T): BigInt {\n    return this._div(BigInt.from(other));\n  }\n\n  // handles sign and allows for easy replacement of algorithm in future update\n  mod<T>(other: T): BigInt {\n    return this._divRemainder(BigInt.from(other));\n  }\n\n  // returns [quotient, remainder]\n  divMod<T>(other: T): BigInt[] {\n    return this._divMod(BigInt.from(other));\n  }\n\n  // TODO: fast division has bug(s) -> using \"slow\" division\n  // private _fastDiv(other: BigInt): BigInt[] {\n  //   if (other.eq(BigInt.fromUInt16(0))) {\n  //     throw new Error(\"Divide by zero\");\n  //   }\n  //   const cmp: i32 = this.magCompareTo(other);\n  //   if (cmp < 0) {\n  //     return [BigInt.fromUInt16(0), this.copy()];\n  //   } else if (cmp == 0) {\n  //     const q = BigInt.fromUInt16(1);\n  //     q.isNeg = this.isNeg != other.isNeg;\n  //     return [q, BigInt.fromUInt16(0)];\n  //   }\n  //   // set up numbers\n  //   let q: BigInt = BigInt.getEmptyResultContainer(\n  //     this.n + 2,\n  //     this.isNeg != other.isNeg,\n  //     this.n + 2\n  //   );\n  //   let x: BigInt = this.abs();\n  //   let y: BigInt = other.abs();\n  //   // norm leading digits of x and y\n  //   let norm: i32 = y.countBits() % BigInt.p;\n  //   if (norm < BigInt.p - 1) {\n  //     norm = BigInt.p - 1 - norm;\n  //     x = x.mulPowTwo(norm);\n  //     y = y.mulPowTwo(norm);\n  //   } else {\n  //     norm = 0;\n  //   }\n  //\n  //   // find leading digit of quotient\n  //   const n: i32 = this.n - 1;\n  //   const t: i32 = other.n - 1;\n  //   const nSubt = n - t;\n  //   y.mulBasisPow(nSubt);\n  //   while (x.compareTo(y) >= 0) {\n  //     q.d[nSubt]++;\n  //     x = x.sub(y);\n  //   }\n  //   y.divBasisPow(nSubt);\n  //   // find remainder of digits\n  //   let temp1: BigInt;\n  //   let temp2: BigInt;\n  //   for (let i = n; i > t; i--) {\n  //     if (i > x.n) continue;\n  //     if (x.d[i] == y.d[t]) {\n  //       q.d[i - t - 1] = (<u32>1 << BigInt.p) - 1;\n  //     } else {\n  //       let r: u64 = (<u64>x.d[i]) << (<u64>BigInt.p);\n  //       r |= <u64>x.d[i - 1];\n  //       r /= <u64>y.d[t];\n  //       if (r > <u64>BigInt.digitMask) {\n  //         r = <u64>BigInt.digitMask;\n  //       }\n  //       q.d[i - t - 1] = <u32>(r & (<u64>BigInt.digitMask));\n  //     }\n  //     // fix up quotient estimation\n  //     q.d[i - t - 1] = ++q.d[i - t - 1] & BigInt.digitMask;\n  //     do {\n  //       q.d[i - t - 1] = --q.d[i - t - 1] & BigInt.digitMask;\n  //       // find left\n  //       temp1 = BigInt.getEmptyResultContainer(2, false, 2);\n  //       temp1.d[0] = t - 1 < 0 ? 0 : y.d[t - 1];\n  //       temp1.d[1] = y.d[t];\n  //       temp1 = temp1.mulInt(q.d[i - t - 1]);\n  //       // find right\n  //       temp2 = BigInt.getEmptyResultContainer(3, false, 3);\n  //       temp2.d[0] = i - 2 < 0 ? 0 : x.d[i - 2];\n  //       temp2.d[1] = i - 1 < 0 ? 0 : x.d[i - 1];\n  //       temp2.d[2] = x.d[i];\n  //     } while (temp1.magCompareTo(temp2) > 0);\n  //\n  //     temp1 = y.mulInt(q.d[i - t - 1]);\n  //     temp1.mulBasisPow(i - t - 1);\n  //     x = x.sub(temp1);\n  //     if (x.isNeg) {\n  //       temp1 = y.copy();\n  //       temp1.mulBasisPow(i - t - 1);\n  //       x = x.add(temp1);\n  //       q.d[i - t - 1] = --q.d[i - t - 1] & BigInt.digitMask;\n  //     }\n  //   }\n  //   // finalize\n  //   q.trimLeadingZeros();\n  //   x.isNeg = x.n != 0 && this.isNeg;\n  //   const r: BigInt = x.divPowTwo(norm);\n  //   return [q, r];\n  // }\n\n  private _div(other: BigInt): BigInt {\n    if (other.eq(BigInt.fromUInt16(0))) {\n      throw new Error('Divide by zero');\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return BigInt.fromUInt16(0);\n    }\n    if (cmp == 0) {\n      const q = BigInt.fromUInt16(1);\n      q.isNeg = this.isNeg != other.isNeg;\n      return q;\n    }\n    const res: BigInt[] = this._divCore(other);\n    const q: BigInt = res[0];\n    q.isNeg = this.isNeg != other.isNeg;\n    q.trimLeadingZeros();\n    return q;\n  }\n\n  private _divRemainder(other: BigInt): BigInt {\n    if (other.eq(BigInt.fromUInt16(0))) {\n      throw new Error('Divide zero error');\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return this.copy();\n    }\n    if (cmp == 0) {\n      return BigInt.fromUInt16(0);\n    }\n    const res: BigInt[] = this._divCore(other);\n    const r: BigInt = res[1];\n    r.isNeg = this.isNeg;\n    r.trimLeadingZeros();\n    return r;\n  }\n\n  // returns [quotient, remainder]\n  private _divMod(other: BigInt): BigInt[] {\n    if (other.eq(BigInt.fromUInt16(0))) {\n      throw new Error('Divide by zero');\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return [BigInt.fromUInt16(0), this.copy()];\n    }\n    if (cmp == 0) {\n      const q = BigInt.fromUInt16(1);\n      q.isNeg = this.isNeg != other.isNeg;\n      return [q, BigInt.fromUInt16(0)];\n    }\n    const res: BigInt[] = this._divCore(other);\n    const q: BigInt = res[0];\n    const r: BigInt = res[1];\n    r.isNeg = this.isNeg;\n    r.trimLeadingZeros();\n    q.isNeg = this.isNeg != other.isNeg;\n    q.trimLeadingZeros();\n    return [q, r];\n  }\n\n  private _divCore(other: BigInt): BigInt[] {\n    let q: BigInt = BigInt.fromUInt16(0);\n    let tempQ = BigInt.fromUInt16(1);\n    let n: i32 = this.countBits() - other.countBits();\n    let tempA = this.abs();\n    let tempB = other.abs();\n    tempB = tempB.mulPowTwo(n);\n    tempQ = tempQ.mulPowTwo(n);\n    for (; n >= 0; n--) {\n      if (tempB.magCompareTo(tempA) <= 0) {\n        tempA = tempA.sub(tempB);\n        q = q.add(tempQ);\n      }\n      tempB = tempB.div2();\n      tempQ = tempQ.div2();\n    }\n    return [q, tempA];\n  }\n\n  // divides and rounds to nearest integer\n  roundedDiv<T>(other: T): BigInt {\n    const divisor: BigInt = BigInt.from(other);\n    if (divisor.eq(BigInt.fromUInt16(0))) {\n      throw new Error('Divide by zero');\n    }\n    if (this.isZero()) {\n      return BigInt.fromUInt16(0);\n    }\n    const r: BigInt = divisor.div2();\n    if (this.isNeg != divisor.isNeg) {\n      r.isNeg = !r.isNeg;\n    }\n    return this.add(r).div(divisor);\n  }\n\n  // SINGLE-DIGIT HELPERS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  addInt(b: u32): BigInt {\n    return this.add(BigInt.fromUInt32(b));\n  }\n\n  subInt(b: u32): BigInt {\n    return this.sub(BigInt.fromUInt32(b));\n  }\n\n  mulInt(b: u32): BigInt {\n    if (b > 268_435_456) {\n      return this.mul(BigInt.fromUInt32(b));\n    }\n    const res = BigInt.fromDigits(this.d, this.isNeg, this.n, this.n + 1);\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u64 = <u64>this.d[i] * <u64>b + <u64>r;\n      res.d[i] = <u32>(rr & (<u64>BigInt.digitMask));\n      r = <u32>(rr >> BigInt.p);\n    }\n    if (r != 0) {\n      res.d[res.n++] = r;\n    }\n    return res;\n  }\n\n  // MUTATES\n  private inplaceMulInt(b: u32): BigInt {\n    if (b > 268_435_456) {\n      return this.mul(BigInt.fromUInt32(b));\n    }\n    this.grow(this.n + 1);\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u64 = <u64>this.d[i] * <u64>b + <u64>r;\n      this.d[i] = <u32>(rr & (<u64>BigInt.digitMask));\n      r = <u32>(rr >> BigInt.p);\n    }\n    if (r != 0) {\n      this.d[this.n++] = r;\n    }\n    return this;\n  }\n\n  divInt(b: u32): BigInt {\n    if (b == 0) throw new Error('Divide by zero');\n    // try optimizations\n    if (b == 1 || this.n == 0) return this.copy();\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) return this.divPowTwo(pow2Bit);\n    // divide\n    const q = BigInt.getEmptyResultContainer(this.n, this.isNeg, this.n);\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      q.d[i] = val;\n    }\n    q.trimLeadingZeros();\n    return q;\n  }\n\n  // MUTATES\n  private inplaceDivInt(b: u32): BigInt {\n    if (b == 0) throw new Error('Divide by zero');\n    // try optimizations\n    if (b == 1 || this.n == 0) return this;\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) return this.divPowTwo(pow2Bit);\n    // divide\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      this.d[i] = val;\n    }\n    this.trimLeadingZeros();\n    return this;\n  }\n\n  modInt(b: u32): u32 {\n    if (b == 0) throw new Error('Divide by zero');\n    // try optimizations\n    if (b == 1 || this.n == 0) {\n      return 0;\n    }\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) {\n      return this.d[0] & (((<u32>1) << pow2Bit) - <u32>1);\n    }\n    // divide\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n    }\n    return <u32>r;\n  }\n\n  // returns [quotient, remainder]\n  divModInt(b: u32): BigInt[] {\n    if (b == 0) throw new Error('Divide by zero');\n    // try optimizations\n    if (b == 1 || this.n == 0) {\n      return [this.copy(), BigInt.ZERO];\n    }\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) {\n      const q: BigInt = this.divPowTwo(pow2Bit);\n      const r: u32 = this.d[0] & (((<u32>1) << pow2Bit) - <u32>1);\n      return [q, BigInt.fromUInt32(r)];\n    }\n    // divide\n    const q = BigInt.getEmptyResultContainer(this.n, this.isNeg, this.n);\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      q.d[i] = val;\n    }\n    q.trimLeadingZeros();\n    return [q, BigInt.fromUInt32(<u32>r)];\n  }\n\n  // divides and rounds to nearest integer\n  roundedDivInt(b: u32): BigInt {\n    if (b == 0) throw new Error('Divide by zero');\n    if (this.isZero()) {\n      return BigInt.fromUInt16(0);\n    }\n    const r: BigInt = BigInt.fromUInt32(b >> 1);\n    if (this.isNeg) {\n      r.isNeg = true;\n    }\n    return this.add(r).divInt(b);\n  }\n\n  // BITWISE OPERATIONS ////////////////////////////////////////////////////////////////////////////////////////////////\n\n  @operator.prefix('~')\n  bitwiseNot(): BigInt {\n    if (this.isNeg) {\n      // ~(-x) == ~(~(x-1)) == x-1\n      return this._subOne(false);\n    }\n    // ~x == -x-1 == -(x+1)\n    return this._addOne(true);\n  }\n\n  bitwiseAnd<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._and(a, b);\n    }\n    if (a.isNeg && b.isNeg) {\n      // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n      // == -(((x-1) | (y-1)) + 1)\n      const a1 = a._subOne(false);\n      const b1 = b._subOne(false);\n      return BigInt._or(a1, b1)._addOne(true);\n    }\n    // Assume that 'a' is the positive BigInt\n    if (a.isNeg) {\n      const temp: BigInt = a;\n      a = b;\n      b = temp;\n    }\n    // x & (-y) == x & ~(y-1) == x &~ (y-1)\n    const b1 = b._subOne(false);\n    return a._andNot(b1);\n  }\n\n  bitwiseOr<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._or(a, b);\n    }\n\n    if (a.isNeg && b.isNeg) {\n      // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n      // == -(((x-1) & (y-1)) + 1)\n      const a1: BigInt = a._subOne(false);\n      const b1: BigInt = b._subOne(false);\n      return BigInt._and(a1, b1)._addOne(true);\n    }\n    // Assume that 'a' is the positive BigInt\n    if (a.isNeg) {\n      const temp: BigInt = a;\n      a = b;\n      b = temp;\n    }\n    // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n    const b1: BigInt = b._subOne(false);\n    return b1._andNot(a)._addOne(true);\n  }\n\n  bitwiseXor<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._xor(a, b);\n    }\n    if (a.isNeg && b.isNeg) {\n      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n      const a1: BigInt = a._subOne(false);\n      const b1: BigInt = b._subOne(false);\n      return BigInt._xor(a1, b1);\n    }\n    // Assume that 'a' is the positive BigInt\n    if (a.isNeg) {\n      const temp: BigInt = a;\n      a = b;\n      b = temp;\n    }\n    // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n    const b1: BigInt = b._subOne(false);\n    return BigInt._xor(a, b1)._addOne(true);\n  }\n\n  // unsigned bitwise AND\n  private static _and(a: BigInt, b: BigInt): BigInt {\n    const numPairs: i32 = a.n < b.n ? a.n : b.n;\n    const res: BigInt = BigInt.getEmptyResultContainer(numPairs, false, numPairs);\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] & b.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bitwise AND NOT (i.e. a & ~b)\n  private _andNot(other: BigInt): BigInt {\n    const numPairs: i32 = this.n < other.n ? this.n : other.n;\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n, false, this.n);\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = this.d[i] & ~other.d[i];\n    }\n    for (; i < this.n; i++) {\n      res.d[i] = this.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bitwise OR\n  private static _or(a: BigInt, b: BigInt): BigInt {\n    let numPairs: i32;\n    let resLength: i32;\n    if (a.n > b.n) {\n      numPairs = b.n;\n      resLength = a.n;\n    } else {\n      numPairs = a.n;\n      resLength = b.n;\n    }\n    const res: BigInt = BigInt.getEmptyResultContainer(resLength, false, resLength);\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] | b.d[i];\n    }\n    for (; i < a.n; i++) {\n      res.d[i] = a.d[i];\n    }\n    for (; i < b.n; i++) {\n      res.d[i] = b.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bitwise XOR\n  private static _xor(a: BigInt, b: BigInt): BigInt {\n    let numPairs: i32;\n    let resLength: i32;\n    if (a.n > b.n) {\n      numPairs = b.n;\n      resLength = a.n;\n    } else {\n      numPairs = a.n;\n      resLength = b.n;\n    }\n    const res: BigInt = BigInt.getEmptyResultContainer(resLength, false, resLength);\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] ^ b.d[i];\n    }\n    for (; i < a.n; i++) {\n      res.d[i] = a.d[i];\n    }\n    for (; i < b.n; i++) {\n      res.d[i] = b.d[i];\n    }\n    return res;\n  }\n\n  // UTILITY ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  countBits(): i32 {\n    if (this.n == 0) return 0;\n    // initialize to bits in fully used digits\n    let bits: i32 = (this.n - 1) * BigInt.p;\n    // count bits used in most significant digit\n    let q: u32 = this.d[this.n - 1];\n    while (q > 0) {\n      ++bits;\n      q >>= 1;\n    }\n    return bits;\n  }\n\n  isOdd(): boolean {\n    return this.n > 0 && (this.d[0] & 1) == 1;\n  }\n\n  isZero(): boolean {\n    return this.n == 0;\n  }\n\n  private static isPow2(b: u32): i32 {\n    for (let i = 1; i < BigInt.p; i++) {\n      if (b == (<u32>1) << i) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // SYNTAX SUGAR ///////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // BigInt with value 0\n  static get ZERO(): BigInt {\n    return BigInt.fromUInt16(0);\n  }\n\n  // BigInt with value 1\n  static get ONE(): BigInt {\n    return BigInt.fromUInt16(1);\n  }\n\n  // BigInt with value -1\n  static get NEG_ONE(): BigInt {\n    const res: BigInt = BigInt.fromUInt16(1);\n    res.isNeg = true;\n    return res;\n  }\n\n  static eq<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.eq(right);\n  }\n\n  @operator('==')\n  private static eqOp(left: BigInt, right: BigInt): boolean {\n    return left.eq(right);\n  }\n\n  static ne<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.ne(right);\n  }\n\n  @operator('!=')\n  private static neOp(left: BigInt, right: BigInt): boolean {\n    return left.ne(right);\n  }\n\n  static lt<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.lt(right);\n  }\n\n  @operator('<')\n  private static ltOp(left: BigInt, right: BigInt): boolean {\n    return left.lt(right);\n  }\n\n  static lte<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.lte(right);\n  }\n\n  @operator('<=')\n  private static lteOp(left: BigInt, right: BigInt): boolean {\n    return left.lte(right);\n  }\n\n  static gt<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.gt(right);\n  }\n\n  @operator('>')\n  private static gtOp(left: BigInt, right: BigInt): boolean {\n    return left.gt(right);\n  }\n\n  static gte<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.gte(right);\n  }\n\n  @operator('>=')\n  private static gteOp(left: BigInt, right: BigInt): boolean {\n    return left.gte(right);\n  }\n\n  static add<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.add(right);\n  }\n\n  @operator('+')\n  private static addOp(left: BigInt, right: BigInt): BigInt {\n    return left.add(right);\n  }\n\n  static sub<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.sub(right);\n  }\n\n  @operator('-')\n  private static subOp(left: BigInt, right: BigInt): BigInt {\n    return left.sub(right);\n  }\n\n  static mul<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.mul(right);\n  }\n\n  @operator('*')\n  private static mulOp(left: BigInt, right: BigInt): BigInt {\n    return left.mul(right);\n  }\n\n  static div<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.div(right);\n  }\n\n  @operator('/')\n  static divOp(left: BigInt, right: BigInt): BigInt {\n    return left.div(right);\n  }\n\n  static mod<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.mod(right);\n  }\n\n  @operator('%')\n  private static modOp(left: BigInt, right: BigInt): BigInt {\n    return left.mod(right);\n  }\n\n  static pow<T>(base: T, k: i32): BigInt {\n    const x: BigInt = BigInt.from(base);\n    return x.pow(k);\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator('**')\n  private static powOp(left: BigInt, right: BigInt): BigInt {\n    return left.pow(right.toInt32());\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator('<<')\n  private static leftShift(left: BigInt, right: BigInt): BigInt {\n    return left.leftShift(right.toInt32());\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator('>>')\n  private static rightShift(left: BigInt, right: BigInt): BigInt {\n    return left.rightShift(right.toInt32());\n  }\n\n  static bitwiseNot<T>(a: T): BigInt {\n    return BigInt.from(a).bitwiseNot();\n  }\n\n  static bitwiseAnd<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitwiseAnd(b);\n  }\n\n  @operator('&')\n  private static bitwiseAndOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitwiseAnd(b);\n  }\n\n  static bitwiseOr<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitwiseOr(b);\n  }\n\n  @operator('|')\n  private static bitwiseOrOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitwiseOr(b);\n  }\n\n  static bitwiseXor<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitwiseXor(b);\n  }\n\n  @operator('^')\n  private static bitwiseXorOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitwiseXor(b);\n  }\n}\n","import { ErrParseValueFail } from '../errors';\nimport { ethereum } from '../abi';\nimport { BigInt } from '../wraptypes/bigint';\n\nexport function uint8ArrayToHex(data: Uint8Array, prefix: string = ''): string {\n  const hexChars = '0123456789abcdef';\n  let result = prefix;\n\n  for (let i = 0; i < data.length; i++) {\n    const byte = data[i];\n    result += hexChars.charAt(byte >> 4) + hexChars.charAt(byte & 0x0f);\n  }\n\n  return result;\n}\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n  if (hex.length % 2 !== 0) {\n    return new Uint8Array(0);\n  }\n  if (hex.startsWith('0x')) {\n    hex = hex.substr(2);\n  }\n  const length = hex.length;\n  const bytes = new Uint8Array(length / 2);\n\n  for (let i: i32 = 0, j: i32 = 0; i < length; i += 2, j++) {\n    bytes[j] = u8.parse(hex.substr(i, 2), 16);\n  }\n\n  return bytes;\n}\n\nexport function stringToUint8Array(s: string): Uint8Array {\n  const buffer = String.UTF8.encode(s);\n  if (buffer.byteLength === 0) {\n    return new Uint8Array(0);\n  }\n  return Uint8Array.wrap(buffer, 0, s.length);\n}\n\nexport function uint8ArrayToAddress(data: Uint8Array): ethereum.Address {\n  const hex = String.UTF8.decode(data.buffer, false);\n  return ethereum.Address.fromHexString(hex);\n}\n\nexport function uint8ArrayToString(arr: Uint8Array): string {\n  return String.UTF8.decode(arr.buffer, false);\n}\n\nexport function uint8ArrayToBool(data: Uint8Array): bool {\n  for (let i = 0; i < data.length; i++) {\n    if (data[i] != 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function boolToUint8Array(b: bool): Uint8Array {\n  const result = new Uint8Array(1);\n  result[0] = b ? 1 : 0;\n\n  return result;\n}\n\nexport function arrayCopyPush<T>(a: Array<T>, elem: T): Array<T> {\n  const res = new Array<T>(a.length + 1);\n  for (let i = 0; i < a.length; i++) {\n    res[i] = a[i];\n  }\n  res[a.length] = elem;\n  return res;\n}\n\nexport function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const result = new Uint8Array(a.length + b.length);\n\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i];\n  }\n\n  for (let i = 0; i < b.length; i++) {\n    result[a.length + i] = b[i];\n  }\n\n  return result;\n}\n\nexport function encodeStringUTF8(str: string): ArrayBuffer {\n  return String.UTF8.encode(str);\n}\n\nexport function decodeUTF8(uint8Array: Uint8Array): string {\n  return String.UTF8.decode(uint8Array.buffer);\n}\n\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nexport function base64Encode(bytes: Uint8Array): string {\n  let result = '';\n  let i = 0;\n  const l = bytes.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64chars.charAt(bytes[i - 2] >> 2);\n    result += base64chars.charAt(((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4));\n    result += base64chars.charAt(((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6));\n    result += base64chars.charAt(bytes[i] & 0x3f);\n  }\n\n  // Handle padding\n  if (i === l + 1) {\n    // two bytes left\n    result += base64chars.charAt(bytes[i - 2] >> 2);\n    result += base64chars.charAt((bytes[i - 2] & 0x03) << 4);\n    result += '==';\n  } else if (i === l) {\n    // one byte left\n    result += base64chars.charAt(bytes[i - 2] >> 2);\n    result += base64chars.charAt(((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4));\n    result += base64chars.charAt((bytes[i - 1] & 0x0f) << 2);\n    result += '=';\n  }\n\n  return result;\n}\n\nexport function base64Decode(str: string): Uint8Array {\n  const pad = str.endsWith('==') ? 2 : str.endsWith('=') ? 1 : 0;\n  const length = (str.length * 3) / 4 - pad;\n  const buffer = new Uint8Array(length);\n  let j = 0;\n\n  for (let i = 0; i < str.length; ) {\n    const c1 = base64chars.indexOf(str.charAt(i++));\n    const c2 = base64chars.indexOf(str.charAt(i++));\n    const c3 = base64chars.indexOf(str.charAt(i++));\n    const c4 = base64chars.indexOf(str.charAt(i++));\n\n    buffer[j++] = (c1 << 2) | (c2 >> 4);\n    if (j < length) {\n      buffer[j++] = ((c2 & 15) << 4) | (c3 >> 2);\n    }\n    if (j < length) {\n      buffer[j++] = ((c3 & 3) << 6) | c4;\n    }\n  }\n\n  return buffer;\n}\n\nexport function parseCallMethod(data: Uint8Array): string {\n  const s = uint8ArrayToHex(data);\n  if (s.startsWith('0x')) {\n    return s.substring(0, 10);\n  }\n  return '0x' + s.substring(0, 8);\n}\n\nexport function toString<T>(value: T): string {\n  if (!value) {\n    return '';\n  }\n  let valueStr: string | null = null;\n  if (value instanceof string) valueStr = <string>value;\n  if (value instanceof bool) valueStr = value ? '1' : '0';\n  if (value instanceof BigInt) valueStr = value.toString();\n  if (value instanceof i8) valueStr = BigInt.fromInt16(<i16>value).toString();\n  if (value instanceof u8) valueStr = BigInt.fromUInt16(<u16>value).toString();\n  if (value instanceof i16) valueStr = BigInt.fromInt16(<i16>value).toString();\n  if (value instanceof u16) valueStr = BigInt.fromUInt16(<u16>value).toString();\n  if (value instanceof i32) valueStr = BigInt.fromInt32(<i32>value).toString();\n  if (value instanceof u32) valueStr = BigInt.fromUInt32(<u32>value).toString();\n  if (value instanceof i64) valueStr = BigInt.fromInt64(<i64>value).toString();\n  if (value instanceof u64) valueStr = BigInt.fromUInt64(<u64>value).toString();\n\n  if (valueStr == null) {\n    valueStr = '';\n  }\n  return valueStr;\n}\n\nexport function fromString<T>(value: string): T {\n  if (isBoolean<T>()) return changetype<T>(value == '1');\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 1) return u8.parse(value, 10) as T;\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 1) return i8.parse(value, 10) as T;\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 2) return u16.parse(value, 10) as T;\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 2) return i16.parse(value, 10) as T;\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 4) return u32.parse(value, 10) as T;\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 4) return i32.parse(value, 10) as T;\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 8) return u64.parse(value, 10) as T;\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 8) return i64.parse(value, 10) as T;\n  if (idof<T>() == idof<BigInt>()) return changetype<T>(BigInt.fromString(value));\n  if (idof<T>() == idof<string>()) return changetype<T>(value);\n\n  throw ErrParseValueFail;\n}\n\nexport function toUint8Array<T>(value: T): Uint8Array {\n  if (!value) {\n    return new Uint8Array(0);\n  }\n  let valueBuffer: Uint8Array | null = null;\n  if (value instanceof string) valueBuffer = stringToUint8Array(<string>value);\n  if (value instanceof bool) valueBuffer = booleanToUint8Array(<bool>value);\n  if (value instanceof BigInt) valueBuffer = (<BigInt>value).toUint8ArrayWithSign();\n  if (value instanceof Uint8Array) valueBuffer = value as Uint8Array;\n  if (value instanceof i8) {\n    valueBuffer = BigInt.fromInt16(<i16>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof u8) {\n    valueBuffer = BigInt.fromUInt16(<u16>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof i16) {\n    valueBuffer = BigInt.fromInt16(<i16>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof u16) {\n    valueBuffer = BigInt.fromUInt16(<u16>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof i32) {\n    valueBuffer = BigInt.fromInt32(<i32>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof u32) {\n    valueBuffer = BigInt.fromUInt32(<u32>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof i64) {\n    valueBuffer = BigInt.fromInt64(<i64>value).toUint8ArrayWithSign();\n  }\n  if (value instanceof u64) {\n    valueBuffer = BigInt.fromUInt64(<u64>value).toUint8ArrayWithSign();\n  }\n\n  if (valueBuffer == null) {\n    valueBuffer = new Uint8Array(0);\n  }\n  return valueBuffer;\n}\n\nexport function fromUint8Array<T>(value: Uint8Array): T {\n  if (isBoolean<T>()) return changetype<T>(value.length > 0 && value[0] > 0);\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 1) {\n    return BigInt.fromUint8ArrayWithSign(value).toUInt8() as T;\n  }\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 1) {\n    return BigInt.fromUint8ArrayWithSign(value).toInt8() as T;\n  }\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 2) {\n    return BigInt.fromUint8ArrayWithSign(value).toUInt16() as T;\n  }\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 2) {\n    return BigInt.fromUint8ArrayWithSign(value).toInt16() as T;\n  }\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 4) {\n    return BigInt.fromUint8ArrayWithSign(value).toUInt32() as T;\n  }\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 4) {\n    return BigInt.fromUint8ArrayWithSign(value).toInt32() as T;\n  }\n  if (isInteger<T>() && !isSigned<T>() && sizeof<T>() == 8)\n    return BigInt.fromUint8ArrayWithSign(value).toUInt64() as T;\n  if (isInteger<T>() && isSigned<T>() && sizeof<T>() == 8)\n    return BigInt.fromUint8ArrayWithSign(value).toInt64() as T;\n  if (idof<T>() == idof<Uint8Array>()) {\n    return value as T;\n  }\n  if (idof<T>() == idof<BigInt>()) {\n    return changetype<T>(BigInt.fromUint8ArrayWithSign(value));\n  }\n  if (idof<T>() == idof<string>()) return changetype<T>(uint8ArrayToString(value));\n\n  throw ErrParseValueFail;\n}\n\nfunction booleanToUint8Array(value: bool): Uint8Array {\n  const array = new Uint8Array(1);\n  array[0] = value ? 1 : 0;\n  return array;\n}\n","import {\n  OperationInput,\n  PostContractCallInput,\n  PostTxExecuteInput,\n  PreContractCallInput,\n  PreTxExecuteInput,\n  TxVerifyInput,\n} from '../proto';\n\nexport interface IAspectBase {\n  /**\n   * isOwner is used to check whether the sender is the owner of the contract.\n   *\n   * @param sender the sender of the transaction, hex string format with 0x prefix.\n   * @returns true if the sender is the owner of the contract, otherwise false.\n   */\n  isOwner(sender: Uint8Array): bool;\n}\n\nexport interface ITransactionVerifier extends IAspectBase {\n  /**\n   * verifyTx is used to verify the transaction. If the transaction is valid,\n   * an ethereum address will be returned. Otherwise, you can either call revert or return empty data\n   * to end the transaction.\n   *\n   * @param input the input for the transaction verification.\n   */\n  verifyTx(input: TxVerifyInput): Uint8Array;\n}\n\nexport interface IPreTxExecuteJP extends IAspectBase {\n  /**\n   * preTxExecute will be triggered before the transaction is executed.\n   *\n   * @param input context information of current join point.\n   */\n  preTxExecute(input: PreTxExecuteInput): void;\n}\n\nexport interface IPreContractCallJP extends IAspectBase {\n  /**\n   * preContractCall will be triggered before the contract call is executed.\n   *\n   * @param input context information of current join point.\n   */\n  preContractCall(input: PreContractCallInput): void;\n}\n\nexport interface IPostContractCallJP extends IAspectBase {\n  /**\n   * postContractCall will be triggered after the contract call is executed.\n   *\n   * @param input context information of current join point.\n   */\n  postContractCall(input: PostContractCallInput): void;\n}\n\nexport interface IPostTxExecuteJP extends IAspectBase {\n  /**\n   * postTxExecute will be triggered after the transaction is executed.\n   *\n   * @param input context information of current join point.\n   */\n  postTxExecute(input: PostTxExecuteInput): void;\n}\n\nexport interface IAspectOperation extends IAspectBase {\n  /**\n   * operation is used to execute the logics within the Aspect.\n   *\n   * @param input input data for the operation.\n   * @return the data of the operation output.\n   */\n  operation(input: OperationInput): Uint8Array;\n}\n\nexport abstract class AspectBase\n  implements\n    IAspectBase,\n    IAspectOperation,\n    IPostTxExecuteJP,\n    IPreTxExecuteJP,\n    IPreContractCallJP,\n    IPostContractCallJP,\n    ITransactionVerifier\n{\n  abstract isOwner(sender: Uint8Array): bool;\n\n  abstract operation(input: OperationInput): Uint8Array;\n\n  abstract preTxExecute(input: PreTxExecuteInput): void;\n\n  abstract postContractCall(input: PostContractCallInput): void;\n\n  abstract preContractCall(input: PreContractCallInput): void;\n\n  abstract postTxExecute(input: PostTxExecuteInput): void;\n\n  abstract verifyTx(input: TxVerifyInput): Uint8Array;\n}\n\nexport class PointCutType {\n  static readonly ON_TX_RECEIVE_METHOD: string = 'onTxReceive';\n  static readonly ON_BLOCK_INITIALIZE_METHOD: string = 'onBlockInitialize';\n\n  static readonly VERIFY_TX: string = 'verifyTx';\n\n  static readonly PRE_TX_EXECUTE_METHOD: string = 'preTxExecute';\n  static readonly PRE_CONTRACT_CALL_METHOD: string = 'preContractCall';\n  static readonly POST_CONTRACT_CALL_METHOD: string = 'postContractCall';\n  static readonly POST_TX_EXECUTE_METHOD: string = 'postTxExecute';\n  static readonly POST_TX_COMMIT: string = 'postTxCommit';\n  static readonly ON_BLOCK_FINALIZE_METHOD: string = 'onBlockFinalize';\n\n  static readonly OPERATION_METHOD: string = 'operation';\n  static readonly IS_OWNER_METHOD: string = 'isOwner';\n\n  static readonly FILTER_TX: string = 'filterTx';\n}\n","import { Protobuf } from 'as-proto/assembly';\nimport { Writer } from 'as-proto/assembly/Writer';\nimport { Any } from '../../proto';\nimport { ABool, AUint8Array } from '../wraptypes/basic-types';\n\nexport class MessageUtil {\n  private static _instance: MessageUtil | null;\n  private constructor() {}\n\n  public static instance(): MessageUtil {\n    if (!this._instance) {\n      this._instance = new MessageUtil();\n    }\n    return this._instance!;\n  }\n\n  public LoadInputBytes(argPtr: i32): Uint8Array {\n    const arg = new AUint8Array();\n    arg.load(argPtr);\n    return arg.get();\n  }\n\n  public StoreOutputBool(out: bool): i32 {\n    const b = new ABool();\n    b.set(out);\n    return b.store();\n  }\n\n  public ToAny<TMessage>(\n    typeUrl: string,\n    message: TMessage,\n    encoder: (message: TMessage, writer: Writer) => void,\n  ): Any {\n    const uint8Array = Protobuf.encode(message, encoder);\n    return new Any(typeUrl, uint8Array);\n  }\n\n  public StringData: string = 'aspect.v2.StringData';\n  public IntData: string = 'aspect.v2.IntData';\n  public BoolData: string = 'aspect.v2.BoolData';\n  public BytesData: string = 'aspect.v2.BytesData';\n  public SateChangeQuery: string = 'aspect.v2.SateChangeQuery';\n  public CallStackQuery: string = 'aspect.v2.CallStackQuery';\n}\n","import { Protobuf } from 'as-proto/assembly';\nimport { IAspectOperation, IPostContractCallJP, IPostTxExecuteJP } from '.';\nimport { AString, AUint8Array, MessageUtil } from '../common';\nimport {\n  OperationInput,\n  PostContractCallInput,\n  PostTxExecuteInput,\n  PreContractCallInput,\n  PreTxExecuteInput,\n  TxVerifyInput,\n} from '../proto';\nimport {\n  IAspectBase,\n  IPreContractCallJP,\n  IPreTxExecuteJP,\n  ITransactionVerifier,\n  PointCutType,\n} from './aspect-interface';\n\nconst messageUtil = MessageUtil.instance();\n\nexport class EntryPoint {\n  private aspectBase: IAspectBase | null = null;\n  private aspectOperation: IAspectOperation | null = null;\n\n  constructor() {}\n\n  public setAspect(aspectBase: IAspectBase): void {\n    this.aspectBase = aspectBase;\n  }\n\n  public setOperationAspect(aspect: IAspectOperation): void {\n    this.aspectOperation = aspect;\n  }\n\n  public getAspect(): IAspectBase | null {\n    return this.aspectBase;\n  }\n\n  public execute(methodPtr: i32, argPtr: i32): i32 {\n    const methodArg = new AString();\n    methodArg.load(methodPtr);\n    const method = methodArg.get();\n\n    if (method == PointCutType.IS_OWNER_METHOD) {\n      return this.isOwner(argPtr);\n    }\n\n    const input = new AUint8Array();\n    input.load(argPtr);\n\n    if (method == PointCutType.VERIFY_TX) {\n      const output = this.verifyTx(input.get());\n      const outputPtr = new AUint8Array(output);\n      return outputPtr.store();\n    }\n    if (method == PointCutType.PRE_TX_EXECUTE_METHOD) {\n      this.preTxExecute(input.get());\n      return 0;\n    }\n    if (method == PointCutType.PRE_CONTRACT_CALL_METHOD) {\n      this.preContractCall(input.get());\n      return 0;\n    }\n    if (method == PointCutType.POST_CONTRACT_CALL_METHOD) {\n      this.postContractCall(input.get());\n      return 0;\n    }\n    if (method == PointCutType.POST_TX_EXECUTE_METHOD) {\n      this.postTxExecute(input.get());\n      return 0;\n    }\n    if (method == PointCutType.OPERATION_METHOD) {\n      const output = this.operation(input.get());\n      const outputPtr = new AUint8Array(output);\n      return outputPtr.store();\n    }\n\n    throw new Error('method ' + method + ' not found or not implemented');\n  }\n\n  private isOwner(argPtr: i32): i32 {\n    if (this.aspectBase != null) {\n      const arg = messageUtil.LoadInputBytes(argPtr);\n      const out = this.aspectBase!.isOwner(arg);\n      return messageUtil.StoreOutputBool(out);\n    }\n    return 0;\n  }\n\n  private verifyTx(rawInput: Uint8Array): Uint8Array {\n    if (this.aspectBase == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<TxVerifyInput>(rawInput, TxVerifyInput.decode);\n    const transactionVerifier = this.aspectBase as ITransactionVerifier;\n    return transactionVerifier.verifyTx(input);\n  }\n\n  private preTxExecute(rawInput: Uint8Array): void {\n    if (this.aspectBase == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<PreTxExecuteInput>(rawInput, PreTxExecuteInput.decode);\n    const preTxExecute = this.aspectBase as IPreTxExecuteJP;\n    preTxExecute.preTxExecute(input);\n  }\n\n  private preContractCall(rawInput: Uint8Array): void {\n    if (this.aspectBase == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<PreContractCallInput>(rawInput, PreContractCallInput.decode);\n    const preContractCall = this.aspectBase as IPreContractCallJP;\n    preContractCall.preContractCall(input);\n  }\n\n  private postContractCall(rawInput: Uint8Array): void {\n    if (this.aspectBase == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<PostContractCallInput>(rawInput, PostContractCallInput.decode);\n    const postContractCall = this.aspectBase as IPostContractCallJP;\n    postContractCall.postContractCall(input);\n  }\n\n  private postTxExecute(rawInput: Uint8Array): void {\n    if (this.aspectBase == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<PostTxExecuteInput>(rawInput, PostTxExecuteInput.decode);\n    const postTxExecute = this.aspectBase as IPostTxExecuteJP;\n    postTxExecute.postTxExecute(input);\n  }\n\n  private operation(rawInput: Uint8Array): Uint8Array {\n    if (this.aspectOperation == null) {\n      throw new Error('aspect is not initialized');\n    }\n\n    const input = Protobuf.decode<OperationInput>(rawInput, OperationInput.decode);\n    const operation = this.aspectOperation as IAspectOperation;\n    return operation.operation(input);\n  }\n}\n","import { EntryPoint } from './aspect-entry';\n\nexport const entryPoint = new EntryPoint();\n\nexport function execute(methodPtr: i32, argPtr: i32): i32 {\n  return entryPoint.execute(methodPtr, argPtr);\n}\n\nexport function allocate(size: i32): i32 {\n  return heap.alloc(size) as i32;\n}\n","import {\n    allocate,\n    entryPoint,\n    execute,\n    IPreContractCallJP,\n    PreContractCallInput,\n    sys,\n    uint8ArrayToAddress,\n    uint8ArrayToHex,\n    UintData,\n} from \"@artela/aspect-libs\";\nimport { Protobuf } from \"as-proto/assembly\";\n\n/**\n\n */\nclass Aspect implements IPreContractCallJP {\n    /**\n     *\n     * @param input\n     */\n    preContractCall(input: PreContractCallInput): void {\n        // read the throttle config from the properties and decode\n        const interval = sys.aspect.property.get<u64>(\"interval\");\n        const limit = sys.aspect.property.get<u64>(\"limit\");\n        // get the contract address, from address and build the storage prefix\n        const contractAddress = uint8ArrayToHex(input.call!.to);\n        const from = uint8ArrayToHex(input.call!.from);\n        const storagePrefix = `${contractAddress}:${from}`;\n        // load the current block timestamp\n        const blockTimeBytes = sys.hostApi.runtimeContext.get('block.header.timestamp');\n        const blockTime = Protobuf.decode<UintData>(blockTimeBytes, UintData.decode).data;\n\n        // load last execution timestamp\n        const lastExecState = sys.aspect.mutableState.get<u64>(storagePrefix + 'lastExecAt');\n        const lastExec = lastExecState.unwrap();\n\n        // check if the throttle interval has passed, revert if not\n        if (lastExec > 0 && (blockTime - lastExec) < interval) {\n            sys.revert('throttled');\n        }\n\n        // check if the throttle limit has been reached, revert if so\n        const execTimeState = sys.aspect.mutableState.get<u64>(storagePrefix + 'execTimes');\n        const execTimes = execTimeState.unwrap();\n        if (limit && execTimes >= limit) {\n            sys.revert('execution time exceed');\n        }\n        // update the throttle state\n        execTimeState.set(execTimes + 1);\n        lastExecState.set(blockTime);\n    }\n\n    /**\n     * isOwner is the governance account implemented by the Aspect, when any of the governance operation\n     * (including upgrade, config, destroy) is made, isOwner method will be invoked to check\n     * against the initiator's account to make sure it has the permission.\n     *\n     * @param sender address of the transaction\n     * @return true if check success, false if check fail\n     */\n    isOwner(sender: Uint8Array): bool {\n        return false;\n    }\n}\n\n// 2.register aspect Instance\nconst aspect = new Aspect()\nentryPoint.setAspect(aspect)\n\n// 3.must export it\nexport { execute, allocate }\n\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { NoFromTxInput } from './no-from-tx-input';\n\nexport class TxVerifyInput {\n  static encode(message: TxVerifyInput, writer: Writer): void {\n    const tx = message.tx;\n    if (tx !== null) {\n      writer.uint32(10);\n      writer.fork();\n      NoFromTxInput.encode(tx, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n\n    writer.uint32(26);\n    writer.bytes(message.validationData);\n\n    writer.uint32(34);\n    writer.bytes(message.callData);\n  }\n\n  static decode(reader: Reader, length: i32): TxVerifyInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new TxVerifyInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = NoFromTxInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.validationData = reader.bytes();\n          break;\n\n        case 4:\n          message.callData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  tx: NoFromTxInput | null;\n  block: BlockInput | null;\n  validationData: Uint8Array;\n  callData: Uint8Array;\n\n  constructor(\n    tx: NoFromTxInput | null = null,\n    block: BlockInput | null = null,\n    validationData: Uint8Array = new Uint8Array(0),\n    callData: Uint8Array = new Uint8Array(0),\n  ) {\n    this.tx = tx;\n    this.block = block;\n    this.validationData = validationData;\n    this.callData = callData;\n  }\n}\n\nexport function encodeTxVerifyInput(message: TxVerifyInput): Uint8Array {\n  return Protobuf.encode(message, TxVerifyInput.encode);\n}\n\nexport function decodeTxVerifyInput(buffer: Uint8Array): TxVerifyInput {\n  return Protobuf.decode<TxVerifyInput>(buffer, TxVerifyInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class NoFromTxInput {\n  static encode(message: NoFromTxInput, writer: Writer): void {\n    writer.uint32(10);\n    writer.bytes(message.hash);\n\n    writer.uint32(18);\n    writer.bytes(message.to);\n  }\n\n  static decode(reader: Reader, length: i32): NoFromTxInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new NoFromTxInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n\n        case 2:\n          message.to = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  hash: Uint8Array;\n  to: Uint8Array;\n\n  constructor(hash: Uint8Array = new Uint8Array(0), to: Uint8Array = new Uint8Array(0)) {\n    this.hash = hash;\n    this.to = to;\n  }\n}\n\nexport function encodeNoFromTxInput(message: NoFromTxInput): Uint8Array {\n  return Protobuf.encode(message, NoFromTxInput.encode);\n}\n\nexport function decodeNoFromTxInput(buffer: Uint8Array): NoFromTxInput {\n  return Protobuf.decode<NoFromTxInput>(buffer, NoFromTxInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class BlockInput {\n  static encode(message: BlockInput, writer: Writer): void {\n    writer.uint32(8);\n    writer.uint64(message.number);\n  }\n\n  static decode(reader: Reader, length: i32): BlockInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new BlockInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.number = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  number: u64;\n\n  constructor(number: u64 = 0) {\n    this.number = number;\n  }\n}\n\nexport function encodeBlockInput(message: BlockInput): Uint8Array {\n  return Protobuf.encode(message, BlockInput.encode);\n}\n\nexport function decodeBlockInput(buffer: Uint8Array): BlockInput {\n  return Protobuf.decode<BlockInput>(buffer, BlockInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { WithFromTxInput } from './with-from-tx-input';\n\nexport class PreTxExecuteInput {\n  static encode(message: PreTxExecuteInput, writer: Writer): void {\n    const tx = message.tx;\n    if (tx !== null) {\n      writer.uint32(10);\n      writer.fork();\n      WithFromTxInput.encode(tx, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): PreTxExecuteInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PreTxExecuteInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = WithFromTxInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  tx: WithFromTxInput | null;\n  block: BlockInput | null;\n\n  constructor(tx: WithFromTxInput | null = null, block: BlockInput | null = null) {\n    this.tx = tx;\n    this.block = block;\n  }\n}\n\nexport function encodePreTxExecuteInput(message: PreTxExecuteInput): Uint8Array {\n  return Protobuf.encode(message, PreTxExecuteInput.encode);\n}\n\nexport function decodePreTxExecuteInput(buffer: Uint8Array): PreTxExecuteInput {\n  return Protobuf.decode<PreTxExecuteInput>(buffer, PreTxExecuteInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class WithFromTxInput {\n  static encode(message: WithFromTxInput, writer: Writer): void {\n    writer.uint32(10);\n    writer.bytes(message.hash);\n\n    writer.uint32(18);\n    writer.bytes(message.to);\n\n    writer.uint32(26);\n    writer.bytes(message.from);\n  }\n\n  static decode(reader: Reader, length: i32): WithFromTxInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new WithFromTxInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n\n        case 2:\n          message.to = reader.bytes();\n          break;\n\n        case 3:\n          message.from = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  hash: Uint8Array;\n  to: Uint8Array;\n  from: Uint8Array;\n\n  constructor(\n    hash: Uint8Array = new Uint8Array(0),\n    to: Uint8Array = new Uint8Array(0),\n    from: Uint8Array = new Uint8Array(0),\n  ) {\n    this.hash = hash;\n    this.to = to;\n    this.from = from;\n  }\n}\n\nexport function encodeWithFromTxInput(message: WithFromTxInput): Uint8Array {\n  return Protobuf.encode(message, WithFromTxInput.encode);\n}\n\nexport function decodeWithFromTxInput(buffer: Uint8Array): WithFromTxInput {\n  return Protobuf.decode<WithFromTxInput>(buffer, WithFromTxInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { PreExecMessageInput } from './pre-exec-message-input';\n\nexport class PreContractCallInput {\n  static encode(message: PreContractCallInput, writer: Writer): void {\n    const call = message.call;\n    if (call !== null) {\n      writer.uint32(10);\n      writer.fork();\n      PreExecMessageInput.encode(call, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): PreContractCallInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PreContractCallInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.call = PreExecMessageInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  call: PreExecMessageInput | null;\n  block: BlockInput | null;\n\n  constructor(call: PreExecMessageInput | null = null, block: BlockInput | null = null) {\n    this.call = call;\n    this.block = block;\n  }\n}\n\nexport function encodePreContractCallInput(message: PreContractCallInput): Uint8Array {\n  return Protobuf.encode(message, PreContractCallInput.encode);\n}\n\nexport function decodePreContractCallInput(buffer: Uint8Array): PreContractCallInput {\n  return Protobuf.decode<PreContractCallInput>(buffer, PreContractCallInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class PreExecMessageInput {\n  static encode(message: PreExecMessageInput, writer: Writer): void {\n    writer.uint32(10);\n    writer.bytes(message.from);\n\n    writer.uint32(18);\n    writer.bytes(message.to);\n\n    writer.uint32(24);\n    writer.uint64(message.index);\n\n    writer.uint32(34);\n    writer.bytes(message.data);\n\n    writer.uint32(42);\n    writer.bytes(message.value);\n\n    writer.uint32(48);\n    writer.uint64(message.gas);\n  }\n\n  static decode(reader: Reader, length: i32): PreExecMessageInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PreExecMessageInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.from = reader.bytes();\n          break;\n\n        case 2:\n          message.to = reader.bytes();\n          break;\n\n        case 3:\n          message.index = reader.uint64();\n          break;\n\n        case 4:\n          message.data = reader.bytes();\n          break;\n\n        case 5:\n          message.value = reader.bytes();\n          break;\n\n        case 6:\n          message.gas = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  from: Uint8Array;\n  to: Uint8Array;\n  index: u64;\n  data: Uint8Array;\n  value: Uint8Array;\n  gas: u64;\n\n  constructor(\n    from: Uint8Array = new Uint8Array(0),\n    to: Uint8Array = new Uint8Array(0),\n    index: u64 = 0,\n    data: Uint8Array = new Uint8Array(0),\n    value: Uint8Array = new Uint8Array(0),\n    gas: u64 = 0,\n  ) {\n    this.from = from;\n    this.to = to;\n    this.index = index;\n    this.data = data;\n    this.value = value;\n    this.gas = gas;\n  }\n}\n\nexport function encodePreExecMessageInput(message: PreExecMessageInput): Uint8Array {\n  return Protobuf.encode(message, PreExecMessageInput.encode);\n}\n\nexport function decodePreExecMessageInput(buffer: Uint8Array): PreExecMessageInput {\n  return Protobuf.decode<PreExecMessageInput>(buffer, PreExecMessageInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { PostExecMessageInput } from './post-exec-message-input';\n\nexport class PostContractCallInput {\n  static encode(message: PostContractCallInput, writer: Writer): void {\n    const call = message.call;\n    if (call !== null) {\n      writer.uint32(10);\n      writer.fork();\n      PostExecMessageInput.encode(call, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): PostContractCallInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PostContractCallInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.call = PostExecMessageInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  call: PostExecMessageInput | null;\n  block: BlockInput | null;\n\n  constructor(call: PostExecMessageInput | null = null, block: BlockInput | null = null) {\n    this.call = call;\n    this.block = block;\n  }\n}\n\nexport function encodePostContractCallInput(message: PostContractCallInput): Uint8Array {\n  return Protobuf.encode(message, PostContractCallInput.encode);\n}\n\nexport function decodePostContractCallInput(buffer: Uint8Array): PostContractCallInput {\n  return Protobuf.decode<PostContractCallInput>(buffer, PostContractCallInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class PostExecMessageInput {\n  static encode(message: PostExecMessageInput, writer: Writer): void {\n    writer.uint32(10);\n    writer.bytes(message.from);\n\n    writer.uint32(18);\n    writer.bytes(message.to);\n\n    writer.uint32(24);\n    writer.uint64(message.index);\n\n    writer.uint32(34);\n    writer.bytes(message.data);\n\n    writer.uint32(42);\n    writer.bytes(message.value);\n\n    writer.uint32(48);\n    writer.uint64(message.gas);\n\n    writer.uint32(58);\n    writer.bytes(message.ret);\n\n    writer.uint32(66);\n    writer.string(message.error);\n  }\n\n  static decode(reader: Reader, length: i32): PostExecMessageInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PostExecMessageInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.from = reader.bytes();\n          break;\n\n        case 2:\n          message.to = reader.bytes();\n          break;\n\n        case 3:\n          message.index = reader.uint64();\n          break;\n\n        case 4:\n          message.data = reader.bytes();\n          break;\n\n        case 5:\n          message.value = reader.bytes();\n          break;\n\n        case 6:\n          message.gas = reader.uint64();\n          break;\n\n        case 7:\n          message.ret = reader.bytes();\n          break;\n\n        case 8:\n          message.error = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  from: Uint8Array;\n  to: Uint8Array;\n  index: u64;\n  data: Uint8Array;\n  value: Uint8Array;\n  gas: u64;\n  ret: Uint8Array;\n  error: string;\n\n  constructor(\n    from: Uint8Array = new Uint8Array(0),\n    to: Uint8Array = new Uint8Array(0),\n    index: u64 = 0,\n    data: Uint8Array = new Uint8Array(0),\n    value: Uint8Array = new Uint8Array(0),\n    gas: u64 = 0,\n    ret: Uint8Array = new Uint8Array(0),\n    error: string = '',\n  ) {\n    this.from = from;\n    this.to = to;\n    this.index = index;\n    this.data = data;\n    this.value = value;\n    this.gas = gas;\n    this.ret = ret;\n    this.error = error;\n  }\n}\n\nexport function encodePostExecMessageInput(message: PostExecMessageInput): Uint8Array {\n  return Protobuf.encode(message, PostExecMessageInput.encode);\n}\n\nexport function decodePostExecMessageInput(buffer: Uint8Array): PostExecMessageInput {\n  return Protobuf.decode<PostExecMessageInput>(buffer, PostExecMessageInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { ReceiptInput } from './receipt-input';\nimport { WithFromTxInput } from './with-from-tx-input';\n\nexport class PostTxExecuteInput {\n  static encode(message: PostTxExecuteInput, writer: Writer): void {\n    const tx = message.tx;\n    if (tx !== null) {\n      writer.uint32(10);\n      writer.fork();\n      WithFromTxInput.encode(tx, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n\n    const receipt = message.receipt;\n    if (receipt !== null) {\n      writer.uint32(26);\n      writer.fork();\n      ReceiptInput.encode(receipt, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): PostTxExecuteInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new PostTxExecuteInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = WithFromTxInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.receipt = ReceiptInput.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  tx: WithFromTxInput | null;\n  block: BlockInput | null;\n  receipt: ReceiptInput | null;\n\n  constructor(\n    tx: WithFromTxInput | null = null,\n    block: BlockInput | null = null,\n    receipt: ReceiptInput | null = null,\n  ) {\n    this.tx = tx;\n    this.block = block;\n    this.receipt = receipt;\n  }\n}\n\nexport function encodePostTxExecuteInput(message: PostTxExecuteInput): Uint8Array {\n  return Protobuf.encode(message, PostTxExecuteInput.encode);\n}\n\nexport function decodePostTxExecuteInput(buffer: Uint8Array): PostTxExecuteInput {\n  return Protobuf.decode<PostTxExecuteInput>(buffer, PostTxExecuteInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class ReceiptInput {\n  static encode(message: ReceiptInput, writer: Writer): void {\n    writer.uint32(8);\n    writer.uint64(message.status);\n  }\n\n  static decode(reader: Reader, length: i32): ReceiptInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new ReceiptInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.status = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  status: u64;\n\n  constructor(status: u64 = 0) {\n    this.status = status;\n  }\n}\n\nexport function encodeReceiptInput(message: ReceiptInput): Uint8Array {\n  return Protobuf.encode(message, ReceiptInput.encode);\n}\n\nexport function decodeReceiptInput(buffer: Uint8Array): ReceiptInput {\n  return Protobuf.decode<ReceiptInput>(buffer, ReceiptInput.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\nimport { BlockInput } from './block-input';\nimport { WithFromTxInput } from './with-from-tx-input';\n\nexport class OperationInput {\n  static encode(message: OperationInput, writer: Writer): void {\n    const tx = message.tx;\n    if (tx !== null) {\n      writer.uint32(10);\n      writer.fork();\n      WithFromTxInput.encode(tx, writer);\n      writer.ldelim();\n    }\n\n    const block = message.block;\n    if (block !== null) {\n      writer.uint32(18);\n      writer.fork();\n      BlockInput.encode(block, writer);\n      writer.ldelim();\n    }\n\n    writer.uint32(26);\n    writer.bytes(message.callData);\n  }\n\n  static decode(reader: Reader, length: i32): OperationInput {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new OperationInput();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = WithFromTxInput.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.block = BlockInput.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.callData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  tx: WithFromTxInput | null;\n  block: BlockInput | null;\n  callData: Uint8Array;\n\n  constructor(\n    tx: WithFromTxInput | null = null,\n    block: BlockInput | null = null,\n    callData: Uint8Array = new Uint8Array(0),\n  ) {\n    this.tx = tx;\n    this.block = block;\n    this.callData = callData;\n  }\n}\n\nexport function encodeOperationInput(message: OperationInput): Uint8Array {\n  return Protobuf.encode(message, OperationInput.encode);\n}\n\nexport function decodeOperationInput(buffer: Uint8Array): OperationInput {\n  return Protobuf.decode<OperationInput>(buffer, OperationInput.decode);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","export function REVERSE<T>(ptr: usize, len: usize): void {\n  if (len > 1) {\n    let\n      i: usize = 0,\n      tail: usize,\n      hlen: usize = len >> 1;\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (sizeof<T>() == 1) {\n        // TODO: Decide later: Does we need this fast path cases?\n        //\n        // if (len == 4) {\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\n        //   return;\n        // }\n        // if (len == 8) {\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\n        //   return;\n        // }\n        tail = len - 8;\n        while (i + 7 < hlen) {\n          let front = ptr + i;\n          let back  = ptr + tail - i;\n          let temp  = bswap(load<u64>(front));\n          store<u64>(front, bswap(load<u64>(back)));\n          store<u64>(back, temp);\n          i += 8;\n        }\n      }\n\n      if (sizeof<T>() == 2) {\n        tail = len - 2;\n        while (i + 1 < hlen) {\n          let front = ptr + (i << 1);\n          let back  = ptr + (tail - i << 1);\n          let temp  = rotr(load<u32>(back), 16);\n          store<u32>(back, rotr(load<u32>(front), 16));\n          store<u32>(front, temp);\n          i += 2;\n        }\n      }\n    }\n\n    tail = len - 1;\n    while (i < hlen) {\n      let front = ptr + (i << alignof<T>());\n      let back  = ptr + (tail - i << alignof<T>());\n      let temp  = load<T>(front);\n      store<T>(front, load<T>(back));\n      store<T>(back, temp);\n      i++;\n    }\n  }\n}\n\nexport function FILL<T>(\n  ptr: usize,\n  len: usize,\n  value: T,\n  start: isize,\n  end: isize\n): void {\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        ptr + <usize>start,\n        u8(value),\n        <usize>(end - start)\n      );\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL <= 1) {\n      if (isInteger<T>()) {\n        // @ts-ignore\n        if (value == <T>0 | value == <T>-1) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              u8(value),\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      } else if (isFloat<T>()) {\n        // for floating non-negative zeros we can use fast memory.fill\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              0,\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      }\n    }\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v4.25.1\n\nimport { Protobuf, Reader, Writer } from 'as-proto/assembly';\n\nexport class UintData {\n  static encode(message: UintData, writer: Writer): void {\n    writer.uint32(8);\n    writer.uint64(message.data);\n  }\n\n  static decode(reader: Reader, length: i32): UintData {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new UintData();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  data: u64;\n\n  constructor(data: u64 = 0) {\n    this.data = data;\n  }\n}\n\nexport function encodeUintData(message: UintData): Uint8Array {\n  return Protobuf.encode(message, UintData.encode);\n}\n\nexport function decodeUintData(buffer: Uint8Array): UintData {\n  return Protobuf.decode<UintData>(buffer, UintData.decode);\n}\n"]}